#!/bin/bash

# GitBuilder - GitHub repository management and build automation tool
# Author: Cascade
# Prompt Engineer: VR51
# Version: 2.0.2
# Created: 2025-04-11
# Updated: 2025-12-07
# License: GNU General Public License v3.0
# Donate: https://paypal.me/vr51/
#
# Copyright (C) 2025 VR51
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

set -euo pipefail
set -o noclobber  # Prevent accidental file overwrites
IFS=$'\n\t'

# Fix backspace/delete key handling in read prompts
stty erase '^?' 2>/dev/null || true

# =============================================================================
# VERSION AND HELP
# =============================================================================
VERSION="2.0.2"
GITHUB_REPO="https://github.com/vr51/GitBuilder"

show_help() {
    # Read help from HELP file if it exists, otherwise show basic help
    local help_file="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/HELP"
    if [ -f "$help_file" ]; then
        # Show the quick reference section (up to the detailed sections)
        sed -n '1,/^=.*HELP SECTIONS INDEX/p' "$help_file" | head -n -1
        echo ""
        echo "For detailed help, run: gitbuilder (then press H)"
        echo "Or view the full HELP file: less $help_file"
    else
        cat << EOF
GitBuilder v${VERSION} - GitHub repository management and build automation tool

Usage: $(basename "$0") [OPTIONS]

Options:
  -h, --help      Show this help message and exit
  -v, --version   Show version information
  -l, --list      List all repositories and exit
  -b, --build ID  Build repository with given ID
  -u, --update    Update all repository commit dates
  --backup FILE   Backup database to FILE
  --restore FILE  Restore database from FILE
  --check-update  Check for GitBuilder updates

Examples:
  $(basename "$0")              # Start interactive mode
  $(basename "$0") -l           # List repositories
  $(basename "$0") -b 1         # Build repository ID 1
  $(basename "$0") --backup ~/backup.sql

Environment Variables:
  GITBUILDER_JOBS   Number of parallel build jobs (default: auto-detect)
  EDITOR            Preferred text editor for notes

For more information, see: $GITHUB_REPO
EOF
    fi
}

show_version() {
    echo "GitBuilder v${VERSION}"
    echo "Copyright (C) 2025 VR51"
    echo "License: GNU GPL v3.0"
}

# Parse command line arguments early (before any initialization)
parse_early_args() {
    case "${1:-}" in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
    esac
}

# Check for help/version before anything else
parse_early_args "$@"

# Required commands and their corresponding packages
declare -A REQUIRED_PACKAGES=(
    [sqlite3]="sqlite3"
    [curl]="curl"
    [jq]="jq"
    [git]="git"
    [make]="make"
    [cmake]="cmake"
    [file]="file"
    [ccache]="ccache"
)

# Configuration
DB_DIR="$HOME/.local/share/gitbuilder"
DB_FILE="$DB_DIR/repos.db"
SRC_DIR="$HOME/.local/share/gitbuilder/src"
GITHUB_API="https://api.github.com"

# Build optimization: detect CPU cores for parallel builds
# Use all cores by default, can be overridden by setting GITBUILDER_JOBS
CPU_CORES=$(nproc 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo 4)
# Ensure we have a valid number, default to 4 if detection fails
[[ ! "$CPU_CORES" =~ ^[0-9]+$ ]] && CPU_CORES=4
PARALLEL_JOBS="${GITBUILDER_JOBS:-$CPU_CORES}"
[[ ! "$PARALLEL_JOBS" =~ ^[0-9]+$ || "$PARALLEL_JOBS" -lt 1 ]] && PARALLEL_JOBS=4
export PARALLEL_JOBS

# RAM disk configuration
RAMDISK_DIR="$HOME/.local/share/gitbuilder/ramdisk"
RAMDISK_MOUNT_POINT="$RAMDISK_DIR/build"
RAMDISK_MIN_FREE_MB=2048  # Minimum free RAM required (2GB)
RAMDISK_ACTIVE=false

# Gitbuildfiles directory (relative to script location)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
GITBUILDFILES_DIR="$SCRIPT_DIR/gitbuildfiles"
HELP_FILE="$SCRIPT_DIR/HELP"

# Additional directories
BUILD_HISTORY_DIR="$DB_DIR/history"
BUILD_PROFILES_DIR="$DB_DIR/profiles"
BINARY_BACKUPS_DIR="$DB_DIR/binary_backups"
DESKTOP_LAUNCHERS_DIR="$HOME/.local/share/applications"
PLUGINS_DIR="$SCRIPT_DIR/plugins"

# Binary backup configuration
BINARY_BACKUP_LIMIT=3  # Maximum backups per repository
CONFIG_FILE="$DB_DIR/config"
BACKUP_DIR="$DB_DIR/backups"

# GitBuilder's own desktop launcher
GITBUILDER_DESKTOP_FILE="$DESKTOP_LAUNCHERS_DIR/gitbuilder.desktop"
GITBUILDER_LAUNCHER_EXISTS=false

# Ensure directories exist
mkdir -p "$DB_DIR" "$SRC_DIR" "$GITBUILDFILES_DIR" "$BUILD_HISTORY_DIR" "$BUILD_PROFILES_DIR" "$BINARY_BACKUPS_DIR" "$PLUGINS_DIR" "$BACKUP_DIR"

# Set secure permissions on database directory
chmod 700 "$DB_DIR" 2>/dev/null || true

# =============================================================================
# THEME SYSTEM
# =============================================================================

# Default theme (can be overridden in config file)
THEME="default"

# Theme definitions
declare -A THEME_DEFAULT=(
    [RED]='\033[0;31m'
    [GREEN]='\033[0;32m'
    [YELLOW]='\033[1;33m'
    [BLUE]='\033[0;34m'
    [CYAN]='\033[0;36m'
    [MAGENTA]='\033[0;35m'
    [WHITE]='\033[1;37m'
    [GRAY]='\033[0;90m'
    [NC]='\033[0m'
)

declare -A THEME_OCEAN=(
    [RED]='\033[38;5;203m'
    [GREEN]='\033[38;5;114m'
    [YELLOW]='\033[38;5;221m'
    [BLUE]='\033[38;5;39m'
    [CYAN]='\033[38;5;87m'
    [MAGENTA]='\033[38;5;141m'
    [WHITE]='\033[38;5;255m'
    [GRAY]='\033[38;5;245m'
    [NC]='\033[0m'
)

declare -A THEME_FOREST=(
    [RED]='\033[38;5;167m'
    [GREEN]='\033[38;5;71m'
    [YELLOW]='\033[38;5;179m'
    [BLUE]='\033[38;5;67m'
    [CYAN]='\033[38;5;73m'
    [MAGENTA]='\033[38;5;139m'
    [WHITE]='\033[38;5;253m'
    [GRAY]='\033[38;5;243m'
    [NC]='\033[0m'
)

declare -A THEME_MONO=(
    [RED]='\033[1;37m'
    [GREEN]='\033[1;37m'
    [YELLOW]='\033[1;37m'
    [BLUE]='\033[0;37m'
    [CYAN]='\033[0;37m'
    [MAGENTA]='\033[0;37m'
    [WHITE]='\033[1;37m'
    [GRAY]='\033[0;90m'
    [NC]='\033[0m'
)

# Apply theme
apply_theme() {
    local theme_name="${1:-default}"
    local -n theme_ref
    
    case "$theme_name" in
        ocean) theme_ref=THEME_OCEAN ;;
        forest) theme_ref=THEME_FOREST ;;
        mono) theme_ref=THEME_MONO ;;
        *) theme_ref=THEME_DEFAULT ;;
    esac
    
    RED="${theme_ref[RED]}"
    GREEN="${theme_ref[GREEN]}"
    YELLOW="${theme_ref[YELLOW]}"
    BLUE="${theme_ref[BLUE]}"
    CYAN="${theme_ref[CYAN]}"
    MAGENTA="${theme_ref[MAGENTA]:-\033[0;35m}"
    WHITE="${theme_ref[WHITE]:-\033[1;37m}"
    GRAY="${theme_ref[GRAY]:-\033[0;90m}"
    NC="${theme_ref[NC]}"
}

# Load configuration file
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    fi
    apply_theme "$THEME"
}

# Save configuration
save_config() {
    cat >| "$CONFIG_FILE" << EOF
# GitBuilder Configuration File
# Generated: $(date -Iseconds)

# Theme: default, ocean, forest, mono
THEME="$THEME"

# Auto-update check interval (days, 0 to disable)
AUTO_UPDATE_CHECK_DAYS="${AUTO_UPDATE_CHECK_DAYS:-7}"

# Desktop notifications (true/false)
NOTIFICATIONS_ENABLED="${NOTIFICATIONS_ENABLED:-true}"

# Default build profile
DEFAULT_PROFILE="${DEFAULT_PROFILE:-}"

# Build queue auto-start (true/false)
BUILD_QUEUE_AUTOSTART="${BUILD_QUEUE_AUTOSTART:-false}"

# Preferred text editor for notes
PREFERRED_EDITOR="${PREFERRED_EDITOR:-}"
EOF
    chmod 600 "$CONFIG_FILE"
}

# Get preferred editor
get_editor() {
    # Check if user has set a preferred editor
    if [ -n "${PREFERRED_EDITOR:-}" ] && command -v "$PREFERRED_EDITOR" >/dev/null 2>&1; then
        echo "$PREFERRED_EDITOR"
        return 0
    fi
    
    # Check common editors in order of preference
    local editors=("nano" "vim" "vi" "emacs" "gedit" "kate" "code" "subl")
    for editor in "${editors[@]}"; do
        if command -v "$editor" >/dev/null 2>&1; then
            echo "$editor"
            return 0
        fi
    done
    
    # No editor found
    echo ""
}

# List installed editors
list_installed_editors() {
    local editors=("nano" "vim" "vi" "emacs" "micro" "ne" "joe" "gedit" "kate" "xed" "pluma" "mousepad" "code" "subl" "atom")
    local installed=()
    
    for editor in "${editors[@]}"; do
        if command -v "$editor" >/dev/null 2>&1; then
            installed+=("$editor")
        fi
    done
    
    echo "${installed[@]}"
}

# Change editor preference
change_editor() {
    local current_editor
    current_editor=$(get_editor)
    
    echo -e "\n${BLUE}Text Editor Settings${NC}"
    echo "============================================"
    echo -e "Current editor: ${GREEN}${current_editor:-none}${NC}"
    echo -e "Preferred editor: ${CYAN}${PREFERRED_EDITOR:-auto-detect}${NC}"
    echo ""
    
    # List installed editors
    echo -e "${YELLOW}Installed editors:${NC}"
    local installed
    installed=$(list_installed_editors)
    
    if [ -z "$installed" ]; then
        echo -e "${RED}No text editors found!${NC}"
    else
        local i=1
        for editor in $installed; do
            if [ "$editor" = "$current_editor" ]; then
                echo -e "  $i) ${GREEN}$editor${NC} (current)"
            else
                echo "  $i) $editor"
            fi
            ((i++))
        done
    fi
    
    echo ""
    echo "============================================"
    echo ""
    echo "Options:"
    echo "  Enter editor name to set as preferred"
    echo "  Enter 'auto' to use auto-detection"
    echo "  Enter 'install' to install nano"
    echo "  Press Enter to cancel"
    echo ""
    
    read -rp "Choice: " choice
    
    case "$choice" in
        "")
            echo -e "${YELLOW}Cancelled${NC}"
            ;;
        auto)
            PREFERRED_EDITOR=""
            save_config
            success "Editor set to auto-detect"
            ;;
        install)
            if install_packages nano; then
                if command -v nano >/dev/null 2>&1; then
                    PREFERRED_EDITOR="nano"
                    save_config
                    success "nano installed and set as preferred editor"
                else
                    error "Failed to install nano"
                fi
            fi
            ;;
        *)
            if command -v "$choice" >/dev/null 2>&1; then
                PREFERRED_EDITOR="$choice"
                save_config
                success "Preferred editor set to: $choice"
            else
                error "Editor '$choice' not found. Please install it first."
            fi
            ;;
    esac
    
    read -rp "Press Enter to continue..."
}

# Initialize config with defaults if not exists
[ ! -f "$CONFIG_FILE" ] && save_config

# Load configuration
load_config

# ANSI color codes (set by theme, these are fallback defaults)
RED="${RED:-\033[0;31m}"
GREEN="${GREEN:-\033[0;32m}"
YELLOW="${YELLOW:-\033[1;33m}"
BLUE="${BLUE:-\033[0;34m}"
CYAN="${CYAN:-\033[0;36m}"
NC="${NC:-\033[0m}"

# Check for required commands and offer to install missing ones
check_requirements() {
    local missing=0
    local missing_pkgs=()

    for cmd in "${!REQUIRED_PACKAGES[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            echo -e "${YELLOW}Missing command: $cmd${NC}"
            missing_pkgs+=("${REQUIRED_PACKAGES[$cmd]}")
            missing=1
        fi
    done

    if [ $missing -eq 1 ]; then
        echo -e "\nThe following packages need to be installed:"
        printf '%s\n' "${missing_pkgs[@]}"
        read -rp "Would you like to install them now? (y/N): " choice
        
        if [[ $choice =~ ^[Yy]$ ]]; then
            install_packages "${missing_pkgs[@]}"
        else
            error "Required packages must be installed to continue."
        fi
    fi
}

# Check for and install build dependencies
check_build_dependencies() {
    local repo_id="$1"
    local dependencies
    
    # Get dependencies from database
    dependencies=$(sqlite3 "$DB_FILE" "SELECT dependencies FROM build_configs WHERE repo_id = $repo_id;")
    
    if [ -z "$dependencies" ]; then
        return 0  # No dependencies specified
    fi
    
    echo -e "\n${BLUE}Checking build dependencies...${NC}"
    
    # Convert space-separated string to array
    IFS=' ' read -r -a deps_array <<< "$dependencies"
    
    local missing=0
    local missing_deps=()
    
    # Check each dependency
    for dep in "${deps_array[@]}"; do
        if ! dpkg -l | grep -q "$dep"; then
            echo -e "${YELLOW}Missing dependency: $dep${NC}"
            missing_deps+=("$dep")
            missing=1
        else
            echo -e "${GREEN}Dependency found: $dep${NC}"
        fi
    done
    
    if [ $missing -eq 1 ]; then
        echo -e "\nThe following dependencies need to be installed:"
        printf '%s\n' "${missing_deps[@]}"
        read -rp "Would you like to install them now? (y/N): " choice
        
        if [[ $choice =~ ^[Yy]$ ]]; then
            if install_packages "${missing_deps[@]}"; then
                echo -e "${GREEN}Dependencies installed successfully${NC}"
            else
                return 1
            fi
        else
            echo -e "${YELLOW}Warning: Missing dependencies may cause build to fail${NC}"
            read -rp "Continue anyway? (y/N): " continue_choice
            if [[ ! $continue_choice =~ ^[Yy]$ ]]; then
                return 1
            fi
        fi
    else
        echo -e "${GREEN}All dependencies are installed${NC}"
    fi
    
    return 0
}

# Initialize SQLite database
init_db() {
    # Drop the old table if it exists (only during initialization)
    if [ ! -f "$DB_FILE" ]; then
        sqlite3 "$DB_FILE" "DROP TABLE IF EXISTS repositories;"
        sqlite3 "$DB_FILE" "DROP TABLE IF EXISTS build_configs;"
    fi

    # Create the repositories table
    sqlite3 "$DB_FILE" <<EOF
CREATE TABLE IF NOT EXISTS repositories (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    url TEXT NOT NULL,
    last_commit TEXT,
    last_commit_check TEXT,
    last_built TEXT,
    build_success INTEGER,
    binary_path TEXT,
    build_type TEXT,
    build_file_path TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
    deleted INTEGER DEFAULT 0
);

CREATE TABLE IF NOT EXISTS build_configs (
    repo_id INTEGER,
    configure_flags TEXT,
    make_flags TEXT,
    cmake_flags TEXT,
    dependencies TEXT,
    strip_debug INTEGER DEFAULT 0,
    use_ramdisk INTEGER DEFAULT 0,
    FOREIGN KEY(repo_id) REFERENCES repositories(id)
);

CREATE TABLE IF NOT EXISTS repository_notes (
    repo_id INTEGER PRIMARY KEY,
    notes TEXT,
    FOREIGN KEY(repo_id) REFERENCES repositories(id)
);

CREATE TABLE IF NOT EXISTS build_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    repo_id INTEGER,
    started_at TEXT DEFAULT CURRENT_TIMESTAMP,
    finished_at TEXT,
    success INTEGER,
    duration_seconds INTEGER,
    download_seconds INTEGER,
    compile_seconds INTEGER,
    download_size_bytes INTEGER,
    log_file TEXT,
    build_profile TEXT,
    FOREIGN KEY(repo_id) REFERENCES repositories(id)
);

CREATE TABLE IF NOT EXISTS build_profiles (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    configure_flags TEXT,
    make_flags TEXT,
    cmake_flags TEXT,
    strip_debug INTEGER DEFAULT 0,
    use_ramdisk INTEGER DEFAULT 0,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS build_queue (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    repo_id INTEGER,
    profile_id INTEGER,
    priority INTEGER DEFAULT 0,
    status TEXT DEFAULT 'pending',
    added_at TEXT DEFAULT CURRENT_TIMESTAMP,
    started_at TEXT,
    FOREIGN KEY(repo_id) REFERENCES repositories(id),
    FOREIGN KEY(profile_id) REFERENCES build_profiles(id)
);

CREATE TABLE IF NOT EXISTS repo_dependencies (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    repo_id INTEGER,
    depends_on_repo_id INTEGER,
    FOREIGN KEY(repo_id) REFERENCES repositories(id),
    FOREIGN KEY(depends_on_repo_id) REFERENCES repositories(id)
);

CREATE TABLE IF NOT EXISTS binary_backups (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    repo_id INTEGER,
    backup_path TEXT NOT NULL,
    original_path TEXT NOT NULL,
    version_label TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(repo_id) REFERENCES repositories(id)
);

CREATE TABLE IF NOT EXISTS desktop_launchers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    repo_id INTEGER,
    desktop_file_path TEXT NOT NULL,
    icon_path TEXT,
    menu_category TEXT DEFAULT 'Development',
    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(repo_id) REFERENCES repositories(id)
);
EOF
    
    # Add new columns if they don't exist (for upgrading existing databases)
    sqlite3 "$DB_FILE" "PRAGMA table_info(repositories);" | grep -q "last_commit_check" || \
        sqlite3 "$DB_FILE" "ALTER TABLE repositories ADD COLUMN last_commit_check TEXT;"
    
    sqlite3 "$DB_FILE" "PRAGMA table_info(repositories);" | grep -q "build_type" || \
        sqlite3 "$DB_FILE" "ALTER TABLE repositories ADD COLUMN build_type TEXT;"
        
    sqlite3 "$DB_FILE" "PRAGMA table_info(repositories);" | grep -q "build_file_path" || \
        sqlite3 "$DB_FILE" "ALTER TABLE repositories ADD COLUMN build_file_path TEXT;"
        
    sqlite3 "$DB_FILE" "PRAGMA table_info(build_configs);" | grep -q "dependencies" || \
        sqlite3 "$DB_FILE" "ALTER TABLE build_configs ADD COLUMN dependencies TEXT;"
    
    sqlite3 "$DB_FILE" "PRAGMA table_info(build_configs);" | grep -q "strip_debug" || \
        sqlite3 "$DB_FILE" "ALTER TABLE build_configs ADD COLUMN strip_debug INTEGER DEFAULT 0;"
    
    sqlite3 "$DB_FILE" "PRAGMA table_info(build_configs);" | grep -q "use_ramdisk" || \
        sqlite3 "$DB_FILE" "ALTER TABLE build_configs ADD COLUMN use_ramdisk INTEGER DEFAULT 0;"
    
    # Add new build timing columns to build_history
    sqlite3 "$DB_FILE" "PRAGMA table_info(build_history);" | grep -q "download_seconds" || \
        sqlite3 "$DB_FILE" "ALTER TABLE build_history ADD COLUMN download_seconds INTEGER;"
    
    sqlite3 "$DB_FILE" "PRAGMA table_info(build_history);" | grep -q "compile_seconds" || \
        sqlite3 "$DB_FILE" "ALTER TABLE build_history ADD COLUMN compile_seconds INTEGER;"
    
    sqlite3 "$DB_FILE" "PRAGMA table_info(build_history);" | grep -q "download_size_bytes" || \
        sqlite3 "$DB_FILE" "ALTER TABLE build_history ADD COLUMN download_size_bytes INTEGER;"
    
    # Create secondary_binaries table for storing all discovered binaries
    sqlite3 "$DB_FILE" <<EOF
CREATE TABLE IF NOT EXISTS secondary_binaries (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    repo_id INTEGER NOT NULL,
    binary_path TEXT NOT NULL,
    binary_name TEXT,
    discovered_at TEXT DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(repo_id) REFERENCES repositories(id),
    UNIQUE(repo_id, binary_path)
);
EOF
}

# Handle errors gracefully
error() {
    echo -e "\n${RED}Error: $1${NC}\n"
    echo "Press 'R' to return to menu..."
    read -r key
    if [[ $key =~ ^[Rr]$ ]]; then
        return 0
    fi
    return 1
}

# Trap errors and handle them gracefully
trap 'trap_error $?' ERR
trap_error() {
    if [ "$1" != "1" ]; then  # Don't show error for normal exit
        echo -e "\n${RED}An unexpected error occurred. Error code: $1${NC}"
        echo -e "Press 'R' to return to menu..."
        read -r key
        if [[ $key =~ ^[Rr]$ ]]; then
            return 0
        fi
    fi
    return 1
}

# Cleanup trap for RAM disk on exit
trap 'cleanup_ramdisk 2>/dev/null' EXIT

# Display success message
success() {
    echo -e "\n${GREEN}Success: $1${NC}"
    if [ "${2:-}" = "wait" ]; then
        echo -e "\nPress any key to continue..."
        read -r -n 1
    fi
}

# =============================================================================
# SECURITY HELPER FUNCTIONS
# =============================================================================

# Escape string for safe SQL insertion (prevents SQL injection)
sql_escape() {
    local input="$1"
    # Escape single quotes by doubling them
    echo "${input//\'/\'\'}"
}

# Validate that input is a positive integer (for IDs)
is_valid_id() {
    local input="$1"
    [[ "$input" =~ ^[0-9]+$ ]] && [ "$input" -gt 0 ]
}

# Sanitize path to prevent directory traversal
sanitize_path() {
    local path="$1"
    # Remove any .. sequences and normalize
    realpath -m "$path" 2>/dev/null || echo "$path"
}

# =============================================================================
# SYSTEM HELPER FUNCTIONS
# =============================================================================

# Install packages using the system package manager
# Usage: install_packages package1 package2 ...
# Returns: 0 on success, 1 on failure
install_packages() {
    local packages=("$@")
    
    if [ ${#packages[@]} -eq 0 ]; then
        return 0
    fi
    
    echo -e "${BLUE}Installing packages: ${packages[*]}${NC}"
    
    if command -v apt-get >/dev/null 2>&1; then
        sudo apt-get update && sudo apt-get install -y "${packages[@]}"
    elif command -v dnf >/dev/null 2>&1; then
        sudo dnf install -y "${packages[@]}"
    elif command -v pacman >/dev/null 2>&1; then
        sudo pacman -S --noconfirm "${packages[@]}"
    elif command -v zypper >/dev/null 2>&1; then
        sudo zypper install -y "${packages[@]}"
    else
        error "Could not detect package manager. Please install packages manually: ${packages[*]}"
        return 1
    fi
}

# Format a date string consistently
# Usage: format_date "date_string" [format]
# format: "short" = YYYY-MM-DD, "long" = YYYY-MM-DD HH:MM (default)
format_date() {
    local date_str="$1"
    local format="${2:-long}"
    
    if [ -z "$date_str" ] || [ "$date_str" = "Unknown" ]; then
        echo "${date_str:-Unknown}"
        return
    fi
    
    local fmt_string
    if [ "$format" = "short" ]; then
        fmt_string="+%Y-%m-%d"
    else
        fmt_string="+%Y-%m-%d %H:%M"
    fi
    
    date -d "$date_str" "$fmt_string" 2>/dev/null || echo "$date_str"
}

# Execute multiple SQL statements in a transaction
# Usage: db_transaction "SQL statement 1; SQL statement 2; ..."
# Returns: 0 on success, 1 on failure (transaction rolled back)
db_transaction() {
    local sql="$1"
    sqlite3 "$DB_FILE" "BEGIN TRANSACTION; $sql COMMIT;" 2>/dev/null
    local status=$?
    if [ $status -ne 0 ]; then
        sqlite3 "$DB_FILE" "ROLLBACK;" 2>/dev/null
        return 1
    fi
    return 0
}

# =============================================================================
# RAM DISK FUNCTIONS
# =============================================================================

# Get available RAM in MB
get_available_ram_mb() {
    local available_kb
    available_kb=$(grep MemAvailable /proc/meminfo 2>/dev/null | awk '{print $2}')
    if [ -z "$available_kb" ]; then
        # Fallback for systems without MemAvailable
        available_kb=$(free | awk '/^Mem:/{print $7}')
    fi
    echo $((available_kb / 1024))
}

# Check if RAM disk can be used
can_use_ramdisk() {
    local required_mb="${1:-$RAMDISK_MIN_FREE_MB}"
    local available_mb
    available_mb=$(get_available_ram_mb)
    
    if [ "$available_mb" -ge "$required_mb" ]; then
        return 0
    else
        return 1
    fi
}

# Setup RAM disk for building
# tmpfs dynamically allocates RAM as needed - size is just a soft limit
setup_ramdisk() {
    local size_mb="${1:-0}"  # 0 means use percentage-based calculation
    
    # Check if already mounted
    if mountpoint -q "$RAMDISK_MOUNT_POINT" 2>/dev/null; then
        echo -e "${YELLOW}RAM disk already mounted at $RAMDISK_MOUNT_POINT${NC}"
        RAMDISK_ACTIVE=true
        return 0
    fi
    
    # Calculate size if not specified or 0
    if [ "$size_mb" -eq 0 ] 2>/dev/null || [ -z "$size_mb" ]; then
        local available_mb
        available_mb=$(get_available_ram_mb)
        # Use 75% of available RAM as soft limit (tmpfs only uses what it needs)
        size_mb=$((available_mb * 75 / 100))
        # Minimum 1GB, no maximum - let the system manage it
        [ "$size_mb" -lt 1024 ] && size_mb=1024
    fi
    
    # Create mount point directory
    mkdir -p "$RAMDISK_MOUNT_POINT"
    
    # Mount tmpfs (doesn't require root if user has permissions, otherwise use sudo)
    # Note: tmpfs only allocates RAM as files are written, the size is just a limit
    if mount -t tmpfs -o size=${size_mb}M,mode=0755 tmpfs "$RAMDISK_MOUNT_POINT" 2>/dev/null; then
        echo -e "${GREEN}RAM disk mounted at $RAMDISK_MOUNT_POINT (up to ${size_mb}MB available)${NC}"
        RAMDISK_ACTIVE=true
        return 0
    else
        # Explain why sudo is needed
        echo -e "${YELLOW}Mounting RAM disk requires elevated privileges.${NC}"
        echo -e "${CYAN}Sudo is needed to create a temporary filesystem in RAM for faster builds.${NC}"
        echo -e "${CYAN}This is safe and the RAM disk will be automatically unmounted after the build.${NC}"
        if sudo mount -t tmpfs -o size=${size_mb}M,mode=0755,uid=$(id -u),gid=$(id -g) tmpfs "$RAMDISK_MOUNT_POINT"; then
            echo -e "${GREEN}RAM disk mounted at $RAMDISK_MOUNT_POINT (up to ${size_mb}MB available)${NC}"
            RAMDISK_ACTIVE=true
            return 0
        else
            echo -e "${RED}Failed to mount RAM disk. Building on regular disk.${NC}"
            RAMDISK_ACTIVE=false
            return 1
        fi
    fi
}

# Cleanup RAM disk after building
cleanup_ramdisk() {
    if [ "$RAMDISK_ACTIVE" = true ] && mountpoint -q "$RAMDISK_MOUNT_POINT" 2>/dev/null; then
        # Sync any pending writes
        sync
        
        # Unmount - try without sudo first
        if umount "$RAMDISK_MOUNT_POINT" 2>/dev/null; then
            echo -e "${GREEN}RAM disk unmounted successfully${NC}"
            RAMDISK_ACTIVE=false
            return 0
        else
            echo -e "${YELLOW}Unmounting RAM disk requires elevated privileges.${NC}"
            echo -e "${CYAN}Sudo is needed to safely release the temporary RAM filesystem.${NC}"
            if sudo umount "$RAMDISK_MOUNT_POINT" 2>/dev/null; then
                echo -e "${GREEN}RAM disk unmounted successfully${NC}"
                RAMDISK_ACTIVE=false
                return 0
            else
                echo -e "${YELLOW}Warning: Could not unmount RAM disk. It will be cleaned up on reboot.${NC}"
                return 1
            fi
        fi
    fi
    return 0
}

# Offer RAM disk option to user
offer_ramdisk() {
    local repo_id="$1"
    local available_mb
    available_mb=$(get_available_ram_mb)
    local potential_size=$((available_mb * 75 / 100))
    
    if can_use_ramdisk; then
        echo -e "\n${CYAN}RAM Disk Available${NC}"
        echo -e "Available RAM: ${GREEN}${available_mb}MB${NC} (will use up to ${potential_size}MB as needed)"
        echo -e "Building on RAM disk can significantly speed up compilation."
        echo -e "${GRAY}Note: tmpfs only uses RAM as files are written, not all at once.${NC}"
        echo ""
        read -rp "Use RAM disk for this build? (y/N): " use_ram
        if [[ "$use_ram" =~ ^[Yy]$ ]]; then
            # Let setup_ramdisk calculate optimal size (75% of available RAM)
            if setup_ramdisk 0; then
                return 0
            fi
        fi
    else
        echo -e "${YELLOW}Note: Insufficient RAM for RAM disk build (${available_mb}MB available, ${RAMDISK_MIN_FREE_MB}MB required)${NC}"
    fi
    return 1
}

# Format duration in seconds to human-readable format (e.g., "5m 32s", "1h 23m")
format_duration() {
    local seconds="$1"
    if [ -z "$seconds" ] || [ "$seconds" -le 0 ] 2>/dev/null; then
        echo "-"
        return
    fi
    
    local hours=$((seconds / 3600))
    local minutes=$(((seconds % 3600) / 60))
    local secs=$((seconds % 60))
    
    if [ "$hours" -gt 0 ]; then
        printf "%dh %dm" "$hours" "$minutes"
    elif [ "$minutes" -gt 0 ]; then
        printf "%dm %ds" "$minutes" "$secs"
    else
        printf "%ds" "$secs"
    fi
}

# Format bytes to human-readable format (e.g., "1.5 MB", "256 KB")
format_bytes() {
    local bytes="$1"
    if [ -z "$bytes" ] || [ "$bytes" -le 0 ] 2>/dev/null; then
        echo "-"
        return
    fi
    
    if [ "$bytes" -ge 1073741824 ]; then
        printf "%.1f GB" "$(echo "scale=1; $bytes / 1073741824" | bc)"
    elif [ "$bytes" -ge 1048576 ]; then
        printf "%.1f MB" "$(echo "scale=1; $bytes / 1048576" | bc)"
    elif [ "$bytes" -ge 1024 ]; then
        printf "%.1f KB" "$(echo "scale=1; $bytes / 1024" | bc)"
    else
        printf "%d B" "$bytes"
    fi
}

# =============================================================================
# UNIFIED TABLE SYSTEM
# =============================================================================
# Global arrays for table data - populated by fetch_repo_data()
declare -a _TABLE_HEADERS=()
declare -a _TABLE_COL_DATA=()  # Flat array: col0_row0, col0_row1, ..., col1_row0, col1_row1, ...
declare -g _TABLE_NUM_COLS=0
declare -g _TABLE_NUM_ROWS=0

# Fetch repository data from database and populate table arrays
# Arguments:
#   $1 - date_format: "full" (YYYY-MM-DD HH:MM) or "short" (MM-DD)
fetch_repo_data() {
    local date_format="${1:-full}"
    
    # Reset global arrays
    _TABLE_HEADERS=("ID" "Name" "URL" "Last Commit" "Last Built" "Duration" "Binary")
    _TABLE_COL_DATA=()
    _TABLE_NUM_COLS=7
    _TABLE_NUM_ROWS=0
    
    # Temporary arrays for each column
    local -a tmp_id=() tmp_name=() tmp_url=() tmp_commit=() tmp_built=() tmp_duration=() tmp_binary=()
    
    while IFS='|' read -r id name url last_commit last_built binary_path; do
        tmp_id+=("$id")
        tmp_name+=("$name")
        tmp_url+=("$url")
        
        # Format the last commit date (always include year)
        local formatted_commit=""
        if [ -n "$last_commit" ] && [ "$last_commit" != "Unknown" ]; then
            if [ "$date_format" = "short" ]; then
                formatted_commit=$(date -d "$last_commit" "+%Y-%m-%d" 2>/dev/null || echo "${last_commit:0:10}")
            else
                formatted_commit=$(date -d "$last_commit" "+%Y-%m-%d %H:%M" 2>/dev/null || echo "$last_commit")
            fi
        else
            formatted_commit="${last_commit:-Unknown}"
        fi
        tmp_commit+=("$formatted_commit")
        
        # Format the last built date (always include year)
        local formatted_built=""
        if [ -n "$last_built" ]; then
            if [ "$date_format" = "short" ]; then
                formatted_built=$(date -d "$last_built" "+%Y-%m-%d" 2>/dev/null || echo "${last_built:0:10}")
            else
                formatted_built=$(date -d "$last_built" "+%Y-%m-%d %H:%M" 2>/dev/null || echo "$last_built")
            fi
        else
            formatted_built="Never"
        fi
        tmp_built+=("$formatted_built")
        
        # Get last build duration from build_history
        local duration_seconds
        duration_seconds=$(sqlite3 "$DB_FILE" "SELECT duration_seconds FROM build_history WHERE repo_id = $id ORDER BY finished_at DESC LIMIT 1;" 2>/dev/null)
        local formatted_duration="-"
        if [ -n "$duration_seconds" ] && [ "$duration_seconds" -gt 0 ] 2>/dev/null; then
            formatted_duration=$(format_duration "$duration_seconds")
        fi
        tmp_duration+=("$formatted_duration")
        
        # Binary status
        local binary_status="No"
        if [ -n "$binary_path" ] && [ -x "$binary_path" ]; then
            binary_status="Yes"
        fi
        tmp_binary+=("$binary_status")
        
        ((_TABLE_NUM_ROWS++)) || true
    done < <(sqlite3 "$DB_FILE" "SELECT id, name, url, last_commit, last_built, binary_path FROM repositories WHERE deleted = 0 ORDER BY id;")
    
    # Flatten into _TABLE_COL_DATA: all of col0, then all of col1, etc.
    # This allows easy access: _TABLE_COL_DATA[col * num_rows + row]
    local i
    for ((i=0; i<_TABLE_NUM_ROWS; i++)); do _TABLE_COL_DATA+=("${tmp_id[i]}"); done
    for ((i=0; i<_TABLE_NUM_ROWS; i++)); do _TABLE_COL_DATA+=("${tmp_name[i]}"); done
    for ((i=0; i<_TABLE_NUM_ROWS; i++)); do _TABLE_COL_DATA+=("${tmp_url[i]}"); done
    for ((i=0; i<_TABLE_NUM_ROWS; i++)); do _TABLE_COL_DATA+=("${tmp_commit[i]}"); done
    for ((i=0; i<_TABLE_NUM_ROWS; i++)); do _TABLE_COL_DATA+=("${tmp_built[i]}"); done
    for ((i=0; i<_TABLE_NUM_ROWS; i++)); do _TABLE_COL_DATA+=("${tmp_duration[i]}"); done
    for ((i=0; i<_TABLE_NUM_ROWS; i++)); do _TABLE_COL_DATA+=("${tmp_binary[i]}"); done
}

# Get cell value from table data
# Arguments: $1=column_index, $2=row_index
_table_get_cell() {
    local col="$1" row="$2"
    local idx=$(( col * _TABLE_NUM_ROWS + row ))
    echo "${_TABLE_COL_DATA[$idx]}"
}

# Render table with dynamic column widths
# Arguments:
#   $1 - title (optional, e.g., "Available Repositories:")
#   $2 - min_widths (optional, pipe-separated, e.g., "2|8|10|10|10|3")
# Uses global _TABLE_HEADERS, _TABLE_COL_DATA, _TABLE_NUM_COLS, _TABLE_NUM_ROWS
render_table() {
    local title="${1:-}"
    local min_widths_str="${2:-}"
    
    if [ "$_TABLE_NUM_ROWS" -eq 0 ]; then
        [ -n "$title" ] && echo -e "${BLUE}${title}${NC}"
        echo -e "${BLUE}No data to display${NC}"
        return
    fi
    
    # Get terminal width
    local term_width
    term_width=$(tput cols 2>/dev/null || echo 80)
    
    # Parse minimum widths
    local -a min_widths=()
    if [ -n "$min_widths_str" ]; then
        IFS='|' read -ra min_widths <<< "$min_widths_str"
    fi
    
    # Calculate optimal width for each column
    local -a col_widths=()
    local col row len max_len
    
    for ((col=0; col<_TABLE_NUM_COLS; col++)); do
        # Start with header width
        max_len=${#_TABLE_HEADERS[col]}
        
        # Check all data in this column
        for ((row=0; row<_TABLE_NUM_ROWS; row++)); do
            local cell_val
            cell_val=$(_table_get_cell "$col" "$row")
            len=${#cell_val}
            [ "$len" -gt "$max_len" ] && max_len=$len
        done
        
        # Apply minimum width if specified
        local min_w=2
        if [ "${min_widths[$col]+isset}" ]; then
            min_w=${min_widths[$col]}
        fi
        [ "$max_len" -lt "$min_w" ] && max_len=$min_w
        
        col_widths+=("$max_len")
    done
    
    # Calculate total table width: │ col │ col │ ... │
    # Each column: 1 (border) + 1 (space) + width + 1 (space) = width + 3
    # Plus final border: +1
    local total_width=1
    for ((col=0; col<_TABLE_NUM_COLS; col++)); do
        total_width=$((total_width + col_widths[col] + 3))
    done
    
    # Shrink columns if table exceeds terminal width
    if [ "$total_width" -gt "$term_width" ]; then
        local excess=$((total_width - term_width))
        
        # Priority order for shrinking: URL (2), Name (1), Commit (3), Built (4)
        local -a shrink_order=(2 1 3 4)
        local -a shrink_mins=(10 8 10 10)
        
        for idx in "${!shrink_order[@]}"; do
            [ "$excess" -le 0 ] && break
            local col_idx=${shrink_order[$idx]}
            local min_w=${shrink_mins[$idx]}
            
            if [ "$col_idx" -lt "$_TABLE_NUM_COLS" ]; then
                local available=$((col_widths[col_idx] - min_w))
                if [ "$available" -gt 0 ]; then
                    if [ "$available" -ge "$excess" ]; then
                        col_widths[col_idx]=$((col_widths[col_idx] - excess))
                        excess=0
                    else
                        col_widths[col_idx]=$min_w
                        excess=$((excess - available))
                    fi
                fi
            fi
        done
    fi
    
    # Build border strings dynamically
    local top_border="┌"
    local header_sep="├"
    local bottom_border="└"
    
    for ((col=0; col<_TABLE_NUM_COLS; col++)); do
        local dashes=""
        local j
        for ((j=0; j<col_widths[col]+2; j++)); do
            dashes+="─"
        done
        if [ "$col" -lt $((_TABLE_NUM_COLS - 1)) ]; then
            top_border+="${dashes}┬"
            header_sep+="${dashes}┼"
            bottom_border+="${dashes}┴"
        else
            top_border+="${dashes}┐"
            header_sep+="${dashes}┤"
            bottom_border+="${dashes}┘"
        fi
    done
    
    # Print title if provided
    [ -n "$title" ] && echo -e "${BLUE}${title}${NC}"
    
    # Print top border
    echo "$top_border"
    
    # Print header row
    local header_row="│"
    for ((col=0; col<_TABLE_NUM_COLS; col++)); do
        local cell
        printf -v cell " %-${col_widths[col]}s " "${_TABLE_HEADERS[col]}"
        header_row+="${cell}│"
    done
    echo "$header_row"
    
    # Print header separator
    echo "$header_sep"
    
    # Print data rows with wrapping support
    for ((row=0; row<_TABLE_NUM_ROWS; row++)); do
        # Get all cell values for this row and wrap them
        local -a row_cells=()
        local -a wrapped_lines=()
        local max_lines=1
        
        for ((col=0; col<_TABLE_NUM_COLS; col++)); do
            local cell_val
            cell_val=$(_table_get_cell "$col" "$row")
            row_cells+=("$cell_val")
            
            # Wrap text if needed
            local wrapped=""
            if [ ${#cell_val} -le "${col_widths[col]}" ]; then
                wrapped="$cell_val"
            else
                # Split into lines of col_width
                local remaining="$cell_val"
                local w="${col_widths[col]}"
                while [ ${#remaining} -gt "$w" ]; do
                    wrapped+="${remaining:0:$w}"$'\n'
                    remaining="${remaining:$w}"
                done
                [ -n "$remaining" ] && wrapped+="$remaining"
            fi
            wrapped_lines+=("$wrapped")
            
            # Count lines
            local line_count
            line_count=$(echo "$wrapped" | wc -l)
            [ "$line_count" -gt "$max_lines" ] && max_lines=$line_count
        done
        
        # Print each line of the wrapped row
        local line_num
        for ((line_num=1; line_num<=max_lines; line_num++)); do
            local row_line="│"
            for ((col=0; col<_TABLE_NUM_COLS; col++)); do
                local cell_line
                cell_line=$(echo "${wrapped_lines[col]}" | sed -n "${line_num}p")
                local cell
                printf -v cell " %-${col_widths[col]}s " "$cell_line"
                row_line+="${cell}│"
            done
            echo "$row_line"
        done
    done
    
    # Print bottom border
    echo "$bottom_border"
}
# =============================================================================
# END UNIFIED TABLE SYSTEM
# =============================================================================

# Validate GitHub URL
validate_github_url() {
    local url="$1"
    if [[ ! "$url" =~ ^https://github.com/[^/]+/[^/]+(.git)?$ ]]; then
        echo -e "${RED}Invalid GitHub URL format. Use: https://github.com/owner/repo${NC}"
        return 1
    fi
    return 0
}

# Get last commit date from GitHub
# Check if commit date needs to be refreshed (older than 4 hours)
needs_commit_refresh() {
    local repo_id="$1"
    
    # Get the last commit check time
    local last_check
    last_check=$(sqlite3 "$DB_FILE" "SELECT last_commit_check FROM repositories WHERE id = $repo_id;")
    
    # If never checked or empty, needs refresh
    if [ -z "$last_check" ]; then
        return 0  # True, needs refresh
    fi
    
    # Calculate time difference in seconds
    local now=$(date +%s)
    local check_time=$(date -d "$last_check" +%s 2>/dev/null || echo 0)
    local diff=$((now - check_time))
    
    # 4 hours = 14400 seconds
    if [ $diff -ge 14400 ]; then
        return 0  # True, needs refresh
    else
        return 1  # False, doesn't need refresh
    fi
}

# Update the last commit date for a repository
update_commit_date() {
    local repo_id="$1"
    local url="$2"
    
    # Check if we need to refresh
    if ! needs_commit_refresh "$repo_id"; then
        return 0
    fi
    
    # Get the last commit date
    local commit_date
    commit_date=$(get_last_commit_date "$url")
    
    # Update the database with the new commit date and check time
    if [ -n "$commit_date" ]; then
        local now=$(date -Iseconds)
        sqlite3 "$DB_FILE" "UPDATE repositories SET 
            last_commit = '$commit_date',
            last_commit_check = '$now'
            WHERE id = $repo_id;"
    fi
}

get_last_commit_date() {
    local url="$1"
    local commit_date=""
    
    # Extract owner and repo from GitHub URL
    local owner repo api_url
    
    # Handle various GitHub URL formats
    if [[ "$url" =~ github\.com[/:]([^/]+)/([^/.]+)(\.git)?$ ]]; then
        owner="${BASH_REMATCH[1]}"
        repo="${BASH_REMATCH[2]}"
        
        # Try GitHub API first (faster and works for large repos)
        api_url="https://api.github.com/repos/$owner/$repo/commits?per_page=1"
        
        # Use curl with timeout to fetch commit info
        local api_response
        api_response=$(curl -s --max-time 10 "$api_url" 2>/dev/null)
        
        if [ -n "$api_response" ] && [ "$api_response" != "[]" ]; then
            # Extract the commit date from JSON response
            commit_date=$(echo "$api_response" | jq -r '.[0].commit.committer.date // empty' 2>/dev/null)
            
            if [ -n "$commit_date" ] && [ "$commit_date" != "null" ]; then
                echo "$commit_date"
                return 0
            fi
        fi
    fi
    
    # Fallback: Try git ls-remote to get latest commit (works for any git repo)
    local latest_sha
    latest_sha=$(timeout 15s git ls-remote --heads "$url" 2>/dev/null | head -1 | awk '{print $1}')
    
    if [ -n "$latest_sha" ]; then
        # For non-GitHub repos or if API failed, try shallow clone as last resort
        local temp_dir
        temp_dir=$(mktemp -d)
        
        if timeout 30s git clone --depth 1 --single-branch "$url" "$temp_dir" >/dev/null 2>&1; then
            commit_date=$(cd "$temp_dir" && git log -1 --format="%cI" 2>/dev/null)
            rm -rf "$temp_dir"
            
            if [ -n "$commit_date" ]; then
                echo "$commit_date"
                return 0
            fi
        else
            rm -rf "$temp_dir"
        fi
    fi
    
    # Return "Unknown" if all methods failed
    echo "Unknown"
}

# Parse gitbuildfile
parse_gitbuildfile() {
    local repo_dir="$1"
    local repo_id="$2"
    local gitbuildfile="$repo_dir/gitbuildfile"
    
    # Check if gitbuildfile exists
    if [ ! -f "$gitbuildfile" ]; then
        return 1
    fi
    
    echo -e "\n${BLUE}Found gitbuildfile. Using build information from file...${NC}"
    
    # Read gitbuildfile contents
    local repo_name=""
    local build_method=""
    local dependencies=""
    local build_file=""
    local configure_flags=""
    local make_flags=""
    local cmake_flags=""
    local binary_path=""
    local notes=""
    
    # Parse each line in the file
    while IFS= read -r line; do
        # Skip comments and empty lines
        [[ $line =~ ^[[:space:]]*# ]] && continue
        [[ -z $line ]] && continue
        
        # Extract key-value pairs
        if [[ $line =~ ^([A-Za-z_]+)=(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            
            # Remove quotes if present
            value="${value#\"}"
            value="${value%\"}"
            value="${value#'}"
            value="${value%'}"
            
            case "$key" in
                REPO_NAME)
                    repo_name="$value"
                    ;;
                BUILD_METHOD)
                    build_method="$value"
                    ;;
                DEPENDENCIES)
                    dependencies="$value"
                    ;;
                BUILD_FILE)
                    build_file="$value"
                    ;;
                CONFIGURE_FLAGS)
                    configure_flags="$value"
                    ;;
                MAKE_FLAGS)
                    make_flags="$value"
                    ;;
                CMAKE_FLAGS)
                    cmake_flags="$value"
                    ;;
                BINARY_PATH)
                    binary_path="$value"
                    ;;
                NOTES)
                    notes="$value"
                    ;;
            esac
        fi
    done < "$gitbuildfile"
    
    # Update database with gitbuildfile information (escape all values)
    if [ -n "$build_method" ]; then
        local escaped_method
        escaped_method=$(sql_escape "$build_method")
        sqlite3 "$DB_FILE" "UPDATE repositories SET build_type = '$escaped_method' WHERE id = $repo_id;"
    fi
    
    if [ -n "$build_file" ]; then
        # Check if the build file path is relative or absolute
        if [[ "$build_file" != /* ]]; then
            build_file="$repo_dir/$build_file"
        fi
        local escaped_build_file
        escaped_build_file=$(sql_escape "$build_file")
        sqlite3 "$DB_FILE" "UPDATE repositories SET build_file_path = '$escaped_build_file' WHERE id = $repo_id;"
    fi
    
    if [ -n "$binary_path" ]; then
        # Check if the binary path is relative or absolute
        if [[ "$binary_path" != /* ]]; then
            binary_path="$repo_dir/$binary_path"
        fi
        local escaped_binary_path
        escaped_binary_path=$(sql_escape "$binary_path")
        sqlite3 "$DB_FILE" "UPDATE repositories SET binary_path = '$escaped_binary_path' WHERE id = $repo_id;"
    fi
    
    # Update build configuration
    if [ -n "$configure_flags" ]; then
        update_build_config "$repo_id" "configure_flags" "$configure_flags"
    fi
    
    if [ -n "$make_flags" ]; then
        update_build_config "$repo_id" "make_flags" "$make_flags"
    fi
    
    if [ -n "$cmake_flags" ]; then
        update_build_config "$repo_id" "cmake_flags" "$cmake_flags"
    fi
    
    if [ -n "$dependencies" ]; then
        update_build_config "$repo_id" "dependencies" "$dependencies"
    fi
    
    if [ -n "$notes" ]; then
        # Store notes in database
        local escaped_notes
        escaped_notes=$(sql_escape "$notes")
        sqlite3 "$DB_FILE" "INSERT OR REPLACE INTO repository_notes (repo_id, notes) VALUES ($repo_id, '$escaped_notes');"
    fi
    
    echo -e "${GREEN}Successfully parsed gitbuildfile${NC}"
    return 0
}

# Find build files recursively up to depth 2
find_build_files() {
    local dir="$1"
    local depth="$2"
    local build_files=()
    
    # Create logs directory if it doesn't exist
    mkdir -p "$dir/logs"
    local log_file="$dir/logs/build_detection.log"
    
    # Log the build detection process (use >| to force overwrite with noclobber)
    echo "Searching for build files in $dir (depth $depth)" >| "$log_file"
    
    # Priority 1: CMakeLists.txt in root (highest priority modern build system)
    if [ -f "$dir/CMakeLists.txt" ]; then
        echo "Found CMakeLists.txt in root directory" >> "$log_file"
        build_files=("$dir/CMakeLists.txt")
        echo "${build_files[@]}"
        return 0
    fi
    
    # Priority 2: autogen.sh with configure.ac/configure.in (autotools needing generation)
    if [ -x "$dir/autogen.sh" ] && { [ -f "$dir/configure.ac" ] || [ -f "$dir/configure.in" ]; }; then
        echo "Found autogen.sh in root directory" >> "$log_file"
        build_files=("$dir/autogen.sh")
        echo "${build_files[@]}"
        return 0
    fi
    
    # Priority 3: configure script (pre-generated autotools)
    if [ -x "$dir/configure" ]; then
        echo "Found configure in root directory" >> "$log_file"
        build_files=("$dir/configure")
        echo "${build_files[@]}"
        return 0
    fi
    
    # Priority 4: Makefile/makefile (simple make projects)
    if [ -f "$dir/Makefile" ] || [ -f "$dir/makefile" ]; then
        echo "Found Makefile in root directory" >> "$log_file"
        if [ -f "$dir/Makefile" ]; then
            build_files=("$dir/Makefile")
        else
            build_files=("$dir/makefile")
        fi
        echo "${build_files[@]}"
        return 0
    fi
    
    # Search for all potential build files
    echo "Searching for build files with find..." >> "$log_file"
    while IFS= read -r -d '' file; do
        echo "Found file: $file" >> "$log_file"
        # Add file to array based on type and priority
        case "$file" in
            # 1. Autotools with autogen
            */autogen.sh)
                if [ -x "$file" ] && { [ -f "${file%/*}/configure.ac" ] || [ -f "${file%/*}/configure.in" ]; }; then
                    echo "Adding autogen.sh with priority" >> "$log_file"
                    build_files=("$file" "${build_files[@]}")
                fi
                ;;
            # 2. Autotools configure
            */configure)
                if [ -x "$file" ]; then
                    echo "Adding configure" >> "$log_file"
                    build_files+=("$file")
                fi
                ;;
            # 3. CMake
            */CMakeLists.txt)
                echo "Adding CMakeLists.txt" >> "$log_file"
                build_files+=("$file")
                ;;
            # 4. Other build systems
            */Makefile)
                # Only add Makefile if no higher-priority build system found in this directory
                local dir_has_priority=false
                for existing in "${build_files[@]}"; do
                    if [ "${existing%/*}" = "${file%/*}" ]; then
                        dir_has_priority=true
                        break
                    fi
                done
                if [ "$dir_has_priority" = false ]; then
                    echo "Adding Makefile" >> "$log_file"
                    build_files+=("$file")
                fi
                ;;
            */setup.py|*/package.json|*/meson.build|*/build.gradle|*/pom.xml)
                echo "Adding other build file: $file" >> "$log_file"
                build_files+=("$file")
                ;;
        esac
    done < <(find "$dir" -maxdepth "$depth" -type f \( \
        -name "autogen.sh" -o \
        -name "configure" -o \
        -name "CMakeLists.txt" -o \
        -name "Makefile" -o \
        -name "setup.py" -o \
        -name "package.json" -o \
        -name "meson.build" -o \
        -name "build.gradle" -o \
        -name "pom.xml" \
    \) -print0 2>> "$log_file")
    
    # If no build files found, try a deeper search for configure and CMakeLists.txt
    if [ ${#build_files[@]} -eq 0 ] && [ "$depth" -lt 3 ]; then
        echo "No build files found at depth $depth, trying depth 3" >> "$log_file"
        build_files=($(find_build_files "$dir" 3))
    fi
    
    # Print the results, ensuring we don't output empty strings
    if [ ${#build_files[@]} -gt 0 ]; then
        echo "Found ${#build_files[@]} build files: ${build_files[@]}" >> "$log_file"
        echo "${build_files[@]}"
    else
        echo "No build files found" >> "$log_file"
    fi
}

# Get build system type from file
get_build_type() {
    local file="$1"
    local filename=$(basename "$file")
    local dirname=$(dirname "$file")
    
    case "$filename" in
        "CMakeLists.txt")
            echo "cmake|$dirname|CMake build system"
            ;;
        "configure")
            # Don't use configure if there's an autogen.sh
            if [ -x "$dirname/autogen.sh" ] && { [ -f "$dirname/configure.ac" ] || [ -f "$dirname/configure.in" ]; }; then
                return 0
            fi
            # Check if it's a custom configure script
            if grep -q '#!/bin/bash' "$file" 2>/dev/null; then
                echo "custom-configure|$dirname|Custom configure script"
            else
                echo "autotools|$dirname|Autotools build system"
            fi
            ;;
        "autogen.sh")
            # Check if configure.ac or configure.in exists
            if [ -f "$dirname/configure.ac" ] || [ -f "$dirname/configure.in" ]; then
                # Run autogen.sh first
                echo "autogen|$dirname|Autotools build system (needs autogen)"
            fi
            ;;
        "Makefile" | "makefile")
            # Don't use Makefile if there's a higher priority build system
            if [ -f "$dirname/CMakeLists.txt" ] || 
               [ -f "$dirname/configure" ] || 
               ([ -x "$dirname/autogen.sh" ] && { [ -f "$dirname/configure.ac" ] || [ -f "$dirname/configure.in" ]; }); then
                return 0
            fi
            echo "make|$dirname|Make build system"
            ;;
        "setup.py")
            echo "python|$dirname|Python package"
            ;;
        "package.json")
            echo "node|$dirname|Node.js package"
            ;;
        "meson.build")
            echo "meson|$dirname|Meson build system"
            ;;
        "build.gradle")
            echo "gradle|$dirname|Gradle build system"
            ;;
        "pom.xml")
            echo "maven|$dirname|Maven build system"
            ;;
    esac
}

# Update all repositories' commit information
update_all_repos() {
    echo -e "\n${BLUE}Updating repository information...${NC}"
    local total
    local updated=0
    total=$(sqlite3 "$DB_FILE" "SELECT COUNT(*) FROM repositories WHERE deleted = 0;")
    
    while IFS='|' read -r id name url; do
        if [ -n "$id" ]; then
            echo -e "\nChecking ${YELLOW}$name${NC}..."
            local commit_date
            commit_date=$(get_last_commit_date "$url")
            if [ "$commit_date" != "Unknown" ]; then
                sqlite3 "$DB_FILE" "UPDATE repositories SET last_commit = '$commit_date' WHERE id = $id;"
                ((updated++))
            fi
        fi
    done < <(sqlite3 "$DB_FILE" "SELECT id, name, url FROM repositories WHERE deleted = 0;")
    
    echo -e "\n${GREEN}Updated $updated of $total repositories${NC}"
    echo -e "Press any key to continue..."
    read -r -n 1
}

# Get build configuration for a repository
get_build_config() {
    local repo_id="$1"
    
    # Get build configuration from database
    local config
    config=$(sqlite3 "$DB_FILE" "SELECT configure_flags, make_flags, cmake_flags, dependencies, COALESCE(strip_debug, 0), COALESCE(use_ramdisk, 0) FROM build_configs WHERE repo_id = $repo_id;")
    
    # If no config exists, create an empty one
    if [ -z "$config" ]; then
        sqlite3 "$DB_FILE" "INSERT INTO build_configs (repo_id, configure_flags, make_flags, cmake_flags, dependencies, strip_debug, use_ramdisk) VALUES ($repo_id, '', '', '', '', 0, 0);"
        echo "||||0|0"
    else
        echo "$config"
    fi
}

# Update build configuration for a repository
update_build_config() {
    local repo_id="$1"
    local field="$2"
    local value="$3"
    
    # Escape value for SQL
    value=$(sql_escape "$value")
    
    # Check if the build config exists
    local exists
    exists=$(sqlite3 "$DB_FILE" "SELECT 1 FROM build_configs WHERE repo_id = $repo_id;")
    
    if [ -z "$exists" ]; then
        # Create a new build config entry
        case "$field" in
            configure_flags)
                sqlite3 "$DB_FILE" "INSERT INTO build_configs (repo_id, configure_flags, make_flags, cmake_flags, dependencies) 
                    VALUES ($repo_id, '$value', '', '', '');"
                ;;
            make_flags)
                sqlite3 "$DB_FILE" "INSERT INTO build_configs (repo_id, configure_flags, make_flags, cmake_flags, dependencies) 
                    VALUES ($repo_id, '', '$value', '', '');"
                ;;
            cmake_flags)
                sqlite3 "$DB_FILE" "INSERT INTO build_configs (repo_id, configure_flags, make_flags, cmake_flags, dependencies) 
                    VALUES ($repo_id, '', '', '$value', '');"
                ;;
            dependencies)
                sqlite3 "$DB_FILE" "INSERT INTO build_configs (repo_id, configure_flags, make_flags, cmake_flags, dependencies) 
                    VALUES ($repo_id, '', '', '', '$value');"
                ;;
        esac
    else
        # Update the existing build config
        sqlite3 "$DB_FILE" "UPDATE build_configs SET $field = '$value' WHERE repo_id = $repo_id;"
    fi
}

# Set build configuration
# Show available build flags for different build systems
show_available_flags() {
    echo -e "\n${BLUE}Available Build Flags${NC}"
    echo -e "${YELLOW}Common Configure Flags:${NC}"
    echo "  --prefix=PREFIX       Install architecture-independent files in PREFIX"
    echo "  --enable-debug        Enable debug symbols and assertions"
    echo "  --disable-shared      Disable shared libraries"
    echo "  --with-X              Enable support for X"
    echo "  --without-X           Disable support for X"
    
    echo -e "\n${YELLOW}Common Make Flags:${NC}"
    echo "  -j N                  Use N parallel jobs"
    echo "  CFLAGS=\"...\"          Set C compiler flags"
    echo "  LDFLAGS=\"...\"         Set linker flags"
    echo "  V=1                   Verbose output"
    
    echo -e "\n${YELLOW}Common CMake Flags:${NC}"
    echo "  -DCMAKE_BUILD_TYPE=Debug|Release|RelWithDebInfo"
    echo "  -DCMAKE_INSTALL_PREFIX=PREFIX"
    echo "  -DBUILD_SHARED_LIBS=ON|OFF"
    echo "  -DCMAKE_C_FLAGS=\"...\""
    
    echo -e "\n${YELLOW}Project-Specific Flags:${NC}"
    echo "  ZEsarUX:              --enable-sdl --enable-ssl"
    echo "  Atari800:             --target=sdl --enable-opengl"
    
    echo -e "\nPress any key to continue..."
    read -r -n 1
}

# Edit build configuration for a repository
edit_build_config() {
    local repo_id="$1"
    local repo_name="$2"
    
    echo -e "\n${BLUE}Build Configuration for $repo_name${NC}"
    echo "Leave blank to keep existing values"
    
    local current_config
    IFS='|' read -r conf_flags make_flags cmake_flags <<< "$(get_build_config "$repo_id")"
    
    read -rp "Configure flags [$conf_flags]: " new_conf_flags
    read -rp "Make flags [$make_flags]: " new_make_flags
    read -rp "CMake flags [$cmake_flags]: " new_cmake_flags
    
    # Use existing values if new ones are empty
    conf_flags="${new_conf_flags:-$conf_flags}"
    make_flags="${new_make_flags:-$make_flags}"
    cmake_flags="${new_cmake_flags:-$cmake_flags}"
    
    sqlite3 "$DB_FILE" "UPDATE build_configs SET 
        configure_flags = '$conf_flags',
        make_flags = '$make_flags',
        cmake_flags = '$cmake_flags'
        WHERE repo_id = $repo_id;"
    
    success "Build configuration updated" wait
}

# Main build configuration menu
set_build_config() {
    local repo_id="$1"
    
    # Get repository name
    local repo_name
    repo_name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $repo_id;")
    
    if [ -z "$repo_name" ]; then
        error "Repository ID $repo_id not found"
        return 1
    fi
    
    while true; do
        clear
        echo -e "\n${BLUE}Build Configuration Menu for $repo_name${NC}"
        echo "1) Add/Edit build flags"
        echo "2) See available build flags"
        echo "3) Return to main menu"
        
        read -rp "Select an option: " choice
        case $choice in
            1) edit_build_config "$repo_id" "$repo_name" ;;
            2) show_available_flags ;;
            3) return 0 ;;
            *) 
                echo -e "${RED}Invalid option${NC}"
                sleep 1
                ;;
        esac
    done
}

find_binary() {
    local dir="$1"
    local name="$2"
    local binaries=()
    
    # First check common build output directories
    local build_dirs=(
        "$dir"
        "$dir/build"
        "$dir/bin"
        "$dir/src"
        "$dir/target/release"
        "$dir/target/debug"
        "$dir/dist"
    )
    
    # Special case for MAME - check if the mame binary exists in the root directory
    if [ -x "$dir/mame" ] && [ -f "$dir/mame" ]; then
        binaries+=("$dir/mame")
    fi
    
    # Check each build directory for binaries
    for build_dir in "${build_dirs[@]}"; do
        if [ -d "$build_dir" ]; then
            # Look for binaries with the same name as the repository
            if [ -x "$build_dir/$name" ] && [ -f "$build_dir/$name" ]; then
                binaries+=("$build_dir/$name")
            fi
            
            # Look for binaries in the build directory
            while IFS= read -r -d '' file; do
                if [ -x "$file" ] && [ -f "$file" ]; then
                    local mime_type
                    mime_type=$(file -b --mime-type "$file")
                    if [[ "$mime_type" == "application/x-executable" || "$mime_type" == "application/x-pie-executable" ]]; then
                        binaries+=("$file")
                    fi
                fi
            done < <(find "$build_dir" -maxdepth 1 -type f -print0 2>/dev/null)
        fi
    done
    
    # If no binaries found in common directories, search the entire directory
    if [ ${#binaries[@]} -eq 0 ]; then
        while IFS= read -r -d '' file; do
            if [ -x "$file" ] && [ -f "$file" ]; then
                local mime_type
                mime_type=$(file -b --mime-type "$file")
                if [[ "$mime_type" == "application/x-executable" || "$mime_type" == "application/x-pie-executable" ]]; then
                    binaries+=("$file")
                fi
            fi
        done < <(find "$dir" -type f -executable -print0 2>/dev/null)
    fi
    
    # Return binaries one per line instead of space-separated
    for binary in "${binaries[@]}"; do
        echo "$binary"
    done
}

# Save all discovered binaries to the database
save_secondary_binaries() {
    local repo_id="$1"
    local dir="$2"
    local name="$3"
    
    # Clear existing secondary binaries for this repo
    sqlite3 "$DB_FILE" "DELETE FROM secondary_binaries WHERE repo_id = $repo_id;"
    
    # Find all binaries
    local binaries
    binaries=$(find_binary "$dir" "$name")
    
    if [ -z "$binaries" ]; then
        return 0
    fi
    
    # Save each binary to the database
    while IFS= read -r binary_path; do
        [ -z "$binary_path" ] && continue
        local binary_name
        binary_name=$(basename "$binary_path")
        local escaped_path escaped_name
        escaped_path=$(sql_escape "$binary_path")
        escaped_name=$(sql_escape "$binary_name")
        sqlite3 "$DB_FILE" "INSERT OR IGNORE INTO secondary_binaries (repo_id, binary_path, binary_name) VALUES ($repo_id, '$escaped_path', '$escaped_name');"
    done <<< "$binaries"
}

# Get secondary binaries for a repository
get_secondary_binaries() {
    local repo_id="$1"
    sqlite3 "$DB_FILE" "SELECT binary_path, binary_name FROM secondary_binaries WHERE repo_id = $repo_id ORDER BY binary_name;"
}

# Launch secondary binary menu
launch_secondary_binary_menu() {
    local repo_id="$1"
    
    if ! is_valid_id "$repo_id"; then
        error "Invalid repository ID"
        return 1
    fi
    
    local repo_name
    repo_name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $repo_id AND deleted = 0;")
    
    if [ -z "$repo_name" ]; then
        error "Repository not found"
        return 1
    fi
    
    while true; do
        clear
        echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
        echo -e "${CYAN}  Secondary Binaries - $repo_name${NC}"
        echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
        echo ""
        
        # Get all binaries for this repo
        local binaries=()
        local binary_names=()
        local i=1
        
        while IFS='|' read -r path name; do
            [ -z "$path" ] && continue
            binaries+=("$path")
            binary_names+=("$name")
            
            # Check if binary exists
            local status="${GREEN}✓${NC}"
            [ ! -x "$path" ] && status="${RED}✗${NC}"
            
            # Mark primary binary
            local primary=""
            local primary_path
            primary_path=$(sqlite3 "$DB_FILE" "SELECT binary_path FROM repositories WHERE id = $repo_id;")
            [ "$path" = "$primary_path" ] && primary=" ${YELLOW}(primary)${NC}"
            
            echo -e "  $i) $status $name$primary"
            echo -e "     ${GRAY}$path${NC}"
            ((i++))
        done < <(get_secondary_binaries "$repo_id")
        
        if [ ${#binaries[@]} -eq 0 ]; then
            echo -e "  ${YELLOW}No binaries found for this repository.${NC}"
            echo -e "  ${GRAY}Build the repository first, or use 'Rescan binaries' to find them.${NC}"
            echo ""
            echo -e "  R) Rescan for binaries"
        else
            echo ""
            echo -e "  ${GRAY}Enter number to launch, or:${NC}"
            echo -e "  R) Rescan for binaries"
        fi
        
        echo -e "  ${GRAY}Esc/Enter) Return to build details${NC}"
        echo ""
        
        local choice esc_status=0
        read_with_esc "Select binary to launch: " choice "" || esc_status=$?
        
        # Handle Esc key
        if [ $esc_status -eq 27 ] || [ -z "$choice" ]; then
            return 0
        fi
        
        case "$choice" in
            [Rr])
                echo -e "${BLUE}Scanning for binaries...${NC}"
                local src_dir="$SRC_DIR/$repo_name"
                if [ -d "$src_dir" ]; then
                    save_secondary_binaries "$repo_id" "$src_dir" "$repo_name"
                    echo -e "${GREEN}Scan complete.${NC}"
                    sleep 1
                else
                    echo -e "${RED}Source directory not found: $src_dir${NC}"
                    sleep 2
                fi
                ;;
            *)
                if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "${#binaries[@]}" ]; then
                    local selected_binary="${binaries[$((choice-1))]}"
                    if [ -x "$selected_binary" ]; then
                        echo -e "${GREEN}Launching: $(basename "$selected_binary")${NC}"
                        nohup "$selected_binary" >/dev/null 2>&1 &
                        echo -e "${GREEN}Binary launched in background.${NC}"
                        sleep 1
                    else
                        echo -e "${RED}Binary not found or not executable: $selected_binary${NC}"
                        sleep 2
                    fi
                else
                    echo -e "${RED}Invalid selection${NC}"
                    sleep 1
                fi
                ;;
        esac
    done
}

# =============================================================================
# UNIFIED FILE BROWSER
# =============================================================================
# Usage: file_browser <start_dir> <mode> [filter_pattern]
# Modes:
#   binary     - Show only executable files (default)
#   file       - Show all files
#   gitbuildfile - Show only gitbuildfile files
#   directory  - Allow directory selection
# Returns: 0 on selection, 1 on cancel
# Selected path is saved to /tmp/gitbuilder_selected_file

file_browser() {
    local start_dir="$1"
    local mode="${2:-binary}"
    local filter_pattern="${3:-}"
    local title="FILE BROWSER"
    local file_label="FILES"
    local temp_file="/tmp/gitbuilder_selected_file"
    
    # Set mode-specific options
    case "$mode" in
        binary)
            title="FILE BROWSER - Select a binary"
            file_label="EXECUTABLE FILES"
            ;;
        file)
            title="FILE BROWSER - Select a file"
            file_label="FILES"
            ;;
        gitbuildfile)
            title="FILE BROWSER - Select a gitbuildfile"
            file_label="GITBUILDFILES"
            filter_pattern="gitbuildfile*"
            ;;
        directory)
            title="FILE BROWSER - Select a directory"
            file_label="(Select a directory)"
            ;;
        image)
            title="FILE BROWSER - Select an image/icon"
            file_label="IMAGE FILES"
            ;;
    esac
    
    # Ensure the directory exists
    if [ ! -d "$start_dir" ]; then
        mkdir -p "$start_dir"
        echo "Created directory: $start_dir"
    fi
    
    # Remove any existing temporary file
    rm -f "$temp_file"
    
    local current_dir
    current_dir=$(realpath "$start_dir")
    
    while true; do
        # Clear screen and show header
        clear
        echo "=========================================="
        echo "$title"
        echo "=========================================="
        echo ""
        echo -e "${CYAN}Current directory:${NC}"
        echo -e "${GREEN}$current_dir${NC}"
        
        # Show parent directory option
        echo ""
        echo "0) .. (Go to parent directory)"
        
        # Initialize arrays for menu items
        declare -a items_path=()
        declare -a items_type=()
        local count=1
        
        # List directories
        echo 
        echo "DIRECTORIES:"
        local has_dirs=false
        for d in "$current_dir"/*/; do
            if [ -d "$d" ] 2>/dev/null; then
                local name
                name=$(basename "$d")
                echo "$count) [DIR] $name/"
                items_path[$count]="$d"
                items_type[$count]="dir"
                ((count++)) || true
                has_dirs=true
            fi
        done
        [ "$has_dirs" = false ] && echo "   (no subdirectories)"
        
        # List files based on mode
        echo 
        echo "$file_label:"
        local has_files=false
        
        case "$mode" in
            binary)
                for f in "$current_dir"/*; do
                    if [ -f "$f" ] && [ -x "$f" ]; then
                        local name
                        name=$(basename "$f")
                        echo "$count) [BIN] $name"
                        items_path[$count]="$f"
                        items_type[$count]="file"
                        ((count++)) || true
                        has_files=true
                    fi
                done
                ;;
            file)
                for f in "$current_dir"/*; do
                    if [ -f "$f" ]; then
                        local name
                        name=$(basename "$f")
                        echo "$count) $name"
                        items_path[$count]="$f"
                        items_type[$count]="file"
                        ((count++)) || true
                        has_files=true
                    fi
                done
                ;;
            gitbuildfile)
                # Show files matching gitbuildfile* pattern
                for f in "$current_dir"/gitbuildfile* "$current_dir"/gitbuildfile; do
                    if [ -f "$f" ] 2>/dev/null; then
                        local name
                        name=$(basename "$f")
                        # Avoid duplicates
                        local already_added=false
                        for existing in "${items_path[@]}"; do
                            [ "$existing" = "$f" ] && already_added=true && break
                        done
                        if [ "$already_added" = false ]; then
                            echo "$count) $name"
                            items_path[$count]="$f"
                            items_type[$count]="file"
                            ((count++)) || true
                            has_files=true
                        fi
                    fi
                done
                ;;
            directory)
                # In directory mode, allow selecting current directory
                echo "$count) [SELECT THIS DIRECTORY]"
                items_path[$count]="$current_dir"
                items_type[$count]="select_dir"
                ((count++)) || true
                has_files=true
                ;;
            image)
                # Show image files (png, svg, ico, xpm, jpg, jpeg)
                for f in "$current_dir"/*; do
                    if [ -f "$f" ]; then
                        local ext="${f##*.}"
                        ext="${ext,,}"  # lowercase
                        case "$ext" in
                            png|svg|ico|xpm|jpg|jpeg|gif|bmp|webp)
                                local name
                                name=$(basename "$f")
                                echo "$count) [IMG] $name"
                                items_path[$count]="$f"
                                items_type[$count]="file"
                                ((count++)) || true
                                has_files=true
                                ;;
                        esac
                    fi
                done
                ;;
        esac
        [ "$has_files" = false ] && echo "   (no matching files)"
        
        # Show navigation options
        echo 
        echo "0) Go to parent directory"
        echo ""
        echo "Esc/q) Cancel and return"
        echo 
        
        # Get user selection with Esc support
        local choice=""
        local char
        echo -n "Select option (0-$((count-1)), Esc to cancel): "
        while IFS= read -r -n1 char; do
            # Check for Esc key
            if [ "$char" = $'\e' ]; then
                echo ""
                return 1
            fi
            # Check for Enter key
            if [ -z "$char" ]; then
                echo ""
                break
            fi
            # Accumulate input
            choice+="$char"
        done
        
        # Process the selection
        if [ "$choice" = "q" ] || [ "$choice" = "Q" ]; then
            return 1
        elif [ "$choice" = "0" ]; then
            # Go to parent directory
            if [ "$current_dir" != "/" ]; then
                current_dir=$(dirname "$current_dir")
            fi
        elif [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -lt "$count" ]; then
            local item_type="${items_type[$choice]}"
            local item_path="${items_path[$choice]}"
            
            if [ "$item_type" = "dir" ]; then
                # Navigate to selected directory
                current_dir="$item_path"
            elif [ "$item_type" = "file" ] || [ "$item_type" = "select_dir" ]; then
                # Save selected path to temporary file
                echo "$item_path" > "$temp_file"
                return 0
            fi
        else
            echo "Invalid selection. Press any key to continue..."
            read -r -n 1
        fi
    done
}

# Wrapper for backward compatibility
browse_for_binary() {
    local start_dir="$1"
    local status=0
    file_browser "$start_dir" "binary" || status=$?
    # Copy to old temp file location for compatibility
    if [ -f "/tmp/gitbuilder_selected_file" ]; then
        cp "/tmp/gitbuilder_selected_file" "/tmp/gitbuilder_selected_binary"
    fi
    return $status
}

# Handle build result
handle_build_result() {
    local repo_id="$1"
    local build_dir="$2"
    local success="$3"
    local log_file="$4"
    local name
    name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $repo_id;")
    
    if [ "$success" -eq 0 ]; then
        echo -e "\n${GREEN}Build completed successfully!${NC}"
        
        # Display repository notes if they exist
        local notes
        notes=$(sqlite3 "$DB_FILE" "SELECT notes FROM repository_notes WHERE repo_id = $repo_id;" || echo "")
        if [ -n "$notes" ]; then
            echo -e "\n${YELLOW}Repository Notes:${NC}"
            echo -e "${CYAN}$notes${NC}"
            echo ""
        fi
        
        # Look for potential binary files
        echo -e "\n${BLUE}Looking for binary files...${NC}"
        local binaries=()
        # Capture each line of output as a separate array element
        mapfile -t binaries < <(find_binary "$build_dir" "$name")
        
        # Save all discovered binaries to database for later access
        save_secondary_binaries "$repo_id" "$build_dir" "$name"
        
        if [ ${#binaries[@]} -gt 0 ]; then
            echo -e "\n${BLUE}Found potential binary files:${NC}"
            echo ""
            local i=1
            for binary in "${binaries[@]}"; do
                echo "$i) $binary"
                ((i++))
            done
            
            echo "b) Browse for binary"
            echo ""
            read -rp "Select binary to register (1-${#binaries[@]}, or 'b' to browse): " choice
            
            local selected_binary
            if [[ $choice =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "${#binaries[@]}" ]; then
                selected_binary="${binaries[$choice-1]}"
            elif [[ $choice == "b" ]]; then
                # Call the browse_for_binary function directly (not in subshell)
                local browse_status=0
                browse_for_binary "$build_dir" || browse_status=$?
                if [ $browse_status -ne 0 ]; then
                    echo -e "${YELLOW}Binary selection cancelled${NC}"
                    return 1
                fi
                
                # Read the selected binary from temp file
                if [ -f "/tmp/gitbuilder_selected_file" ]; then
                    selected_binary=$(cat "/tmp/gitbuilder_selected_file")
                    rm -f "/tmp/gitbuilder_selected_file"
                else
                    echo -e "${RED}Error: No binary selected${NC}"
                    return 1
                fi
                
                # Verify the selected binary exists and is executable
                if [ ! -x "$selected_binary" ]; then
                    echo -e "${RED}Error: Selected binary is not executable${NC}"
                    return 1
                fi
            else
                return 1
            fi
            
            echo -e "${GREEN}Selected binary: $selected_binary${NC}"
            
            # Save binary path to database
            sqlite3 "$DB_FILE" "UPDATE repositories SET 
                binary_path = '$selected_binary'
                WHERE id = $repo_id;"
            
            read -rp "Would you like to launch the binary now? (y/N): " run_choice
            if [[ $run_choice =~ ^[Yy]$ ]]; then
                launch_binary "$repo_id"
            fi
            
            # Check desktop launcher - update if exists, offer to create if not
            if repo_has_desktop_launcher "$repo_id"; then
                update_desktop_launcher_if_needed "$repo_id"
            else
                read -rp "Would you like to create a desktop launcher? (y/N): " launcher_choice
                if [[ $launcher_choice =~ ^[Yy]$ ]]; then
                    create_desktop_launcher "$repo_id"
                fi
            fi
        else
            echo -e "\n${YELLOW}No binaries found automatically.${NC}"
            read -rp "Would you like to browse for the binary? (Y/n): " browse_choice
            if [[ ! $browse_choice =~ ^[Nn]$ ]]; then
                local browse_status=0
                # Call the browse_for_binary function directly (not in subshell)
                browse_for_binary "$build_dir" || browse_status=$?
                if [ $browse_status -eq 0 ] && [ -f "/tmp/gitbuilder_selected_file" ]; then
                    local selected_binary
                    selected_binary=$(cat "/tmp/gitbuilder_selected_file")
                    rm -f "/tmp/gitbuilder_selected_file"
                    
                    if [ -x "$selected_binary" ]; then
                        echo -e "${GREEN}Selected binary: $selected_binary${NC}"
                        
                        # Save binary path to database
                        sqlite3 "$DB_FILE" "UPDATE repositories SET 
                            binary_path = '$selected_binary'
                            WHERE id = $repo_id;"
                        
                        read -rp "Would you like to launch the binary now? (y/N): " run_choice
                        if [[ $run_choice =~ ^[Yy]$ ]]; then
                            launch_binary "$repo_id"
                        fi
                        
                        # Check desktop launcher - update if exists, offer to create if not
                        if repo_has_desktop_launcher "$repo_id"; then
                            update_desktop_launcher_if_needed "$repo_id"
                        else
                            read -rp "Would you like to create a desktop launcher? (y/N): " launcher_choice
                            if [[ $launcher_choice =~ ^[Yy]$ ]]; then
                                create_desktop_launcher "$repo_id"
                            fi
                        fi
                    fi
                fi
            fi
        fi
    else
        echo -e "\n${RED}Build failed!${NC}"
        read -rp "Would you like to see the build log? (y/N): " choice
        if [[ $choice =~ ^[Yy]$ ]]; then
            less "$log_file"
        fi
    fi
    
    # Update build status in database
    sqlite3 "$DB_FILE" "UPDATE repositories SET 
        build_success = $success,
        last_built = datetime('now')
        WHERE id = $repo_id;"
}

# Clean build cache for a repository directory
# Removes build artifacts while preserving source files
clean_build_cache() {
    local repo_dir="$1"
    
    if [ ! -d "$repo_dir" ]; then
        echo -e "${RED}Directory not found: $repo_dir${NC}"
        return 1
    fi
    
    cd "$repo_dir" || return 1
    
    local cleaned=0
    
    # CMake build directories
    if [ -d "build" ]; then
        echo -e "  ${CYAN}Removing CMake build directory...${NC}"
        rm -rf "build"
        ((cleaned++)) || true
    fi
    
    if [ -d "_build" ]; then
        echo -e "  ${CYAN}Removing _build directory...${NC}"
        rm -rf "_build"
        ((cleaned++)) || true
    fi
    
    # Meson build directory
    if [ -d "builddir" ]; then
        echo -e "  ${CYAN}Removing Meson builddir...${NC}"
        rm -rf "builddir"
        ((cleaned++)) || true
    fi
    
    # Autotools generated files
    if [ -f "Makefile" ] && [ -f "configure" ]; then
        echo -e "  ${CYAN}Running make clean...${NC}"
        make clean 2>/dev/null || true
        make distclean 2>/dev/null || true
        ((cleaned++)) || true
    fi
    
    # Object files and libraries
    local obj_count
    obj_count=$(find . -name "*.o" -o -name "*.a" -o -name "*.so" -o -name "*.lo" -o -name "*.la" 2>/dev/null | wc -l)
    if [ "$obj_count" -gt 0 ]; then
        echo -e "  ${CYAN}Removing $obj_count object/library files...${NC}"
        find . -name "*.o" -delete 2>/dev/null || true
        find . -name "*.a" -delete 2>/dev/null || true
        find . -name "*.so" -delete 2>/dev/null || true
        find . -name "*.lo" -delete 2>/dev/null || true
        find . -name "*.la" -delete 2>/dev/null || true
        ((cleaned++)) || true
    fi
    
    # Libtool directories
    if [ -d ".libs" ] || find . -type d -name ".libs" 2>/dev/null | grep -q .; then
        echo -e "  ${CYAN}Removing .libs directories...${NC}"
        find . -type d -name ".libs" -exec rm -rf {} + 2>/dev/null || true
        ((cleaned++)) || true
    fi
    
    # Autotools cache
    if [ -d "autom4te.cache" ]; then
        echo -e "  ${CYAN}Removing autom4te.cache...${NC}"
        rm -rf "autom4te.cache"
        ((cleaned++)) || true
    fi
    
    # CMake cache files
    if [ -f "CMakeCache.txt" ]; then
        echo -e "  ${CYAN}Removing CMake cache...${NC}"
        rm -f CMakeCache.txt
        rm -rf CMakeFiles
        ((cleaned++)) || true
    fi
    
    # Python build artifacts
    if [ -d "__pycache__" ] || [ -d "build" ] || [ -d "dist" ] || [ -d "*.egg-info" ]; then
        echo -e "  ${CYAN}Removing Python build artifacts...${NC}"
        find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
        find . -type d -name "*.egg-info" -exec rm -rf {} + 2>/dev/null || true
        rm -rf dist 2>/dev/null || true
        ((cleaned++)) || true
    fi
    
    # Node.js
    if [ -d "node_modules" ]; then
        echo -e "  ${CYAN}Removing node_modules...${NC}"
        rm -rf "node_modules"
        ((cleaned++)) || true
    fi
    
    # Gradle
    if [ -d ".gradle" ]; then
        echo -e "  ${CYAN}Removing Gradle cache...${NC}"
        rm -rf ".gradle"
        rm -rf "build" 2>/dev/null || true
        ((cleaned++)) || true
    fi
    
    # Maven
    if [ -d "target" ]; then
        echo -e "  ${CYAN}Removing Maven target directory...${NC}"
        rm -rf "target"
        ((cleaned++)) || true
    fi
    
    # Rust
    if [ -d "target" ] && [ -f "Cargo.toml" ]; then
        echo -e "  ${CYAN}Removing Rust target directory...${NC}"
        rm -rf "target"
        ((cleaned++)) || true
    fi
    
    if [ "$cleaned" -eq 0 ]; then
        echo -e "  ${YELLOW}No build cache found to clean${NC}"
    else
        echo -e "  ${GREEN}Cleaned $cleaned build artifact type(s)${NC}"
    fi
    
    return 0
}

# Execute build command with timeout and progress
execute_build() {
    local type="$1"
    local dir="$2"
    local repo_id="$3"
    shift 3
    local args=("$@")
    local log_file
    local build_dir="$dir"
    
    # Create logs directory if it doesn't exist
    local log_dir="$dir/logs"
    mkdir -p "$log_dir"
    
    # Create a unique log file for this build
    log_file="$log_dir/build_$(date +%Y%m%d_%H%M%S).log"
    
    # Record build start time for history
    local build_start_time
    build_start_time=$(date +%s)
    
    # Get build configuration
    local configure_flags make_flags cmake_flags dependencies strip_debug use_ramdisk
    IFS='|' read -r configure_flags make_flags cmake_flags dependencies strip_debug use_ramdisk < <(get_build_config "$repo_id")
    
    # Ensure PARALLEL_JOBS has a valid value (must be done before string interpolation)
    if [[ ! "$PARALLEL_JOBS" =~ ^[0-9]+$ ]] || [ -z "$PARALLEL_JOBS" ] || [ "$PARALLEL_JOBS" -lt 1 ] 2>/dev/null; then
        PARALLEL_JOBS=4
    fi
    
    # Remove any malformed -j flags (e.g., "-j" without a number, or "-j ")
    make_flags=$(echo "$make_flags" | sed -E 's/-j[[:space:]]*([^0-9]|$)//g')
    
    # Build the jobs flag with explicit number
    local jobs_flag="-j$PARALLEL_JOBS"
    
    # Add parallel jobs flag if not already specified in make_flags
    if [[ ! "$make_flags" =~ -j[[:space:]]*[0-9]+ ]]; then
        if [ -n "$make_flags" ] && [ "$make_flags" != " " ]; then
            make_flags="$jobs_flag $make_flags"
        else
            make_flags="$jobs_flag"
        fi
    fi
    # Trim any leading/trailing whitespace from make_flags
    make_flags="${make_flags## }"
    make_flags="${make_flags%% }"
    # Final safety check - if make_flags is empty or just whitespace, set to jobs_flag
    [[ -z "${make_flags// }" ]] && make_flags="$jobs_flag"
    
    # Handle strip debug symbols option
    local cflags_extra=""
    if [ "$strip_debug" = "1" ]; then
        cflags_extra="-O2 -DNDEBUG"
        echo -e "${CYAN}Debug symbols will be stripped (optimized build)${NC}"
    fi
    
    # Handle RAM disk option
    local actual_build_dir="$dir"
    if [ "$use_ramdisk" = "1" ] && can_use_ramdisk; then
        # Let setup_ramdisk calculate optimal size (75% of available RAM)
        if setup_ramdisk 0; then
            actual_build_dir="$RAMDISK_MOUNT_POINT"
            echo -e "${CYAN}Building on RAM disk for faster compilation${NC}"
            # Copy source to RAM disk
            echo -e "${BLUE}Copying source to RAM disk...${NC}"
            cp -a "$dir"/* "$actual_build_dir/" 2>/dev/null || true
        fi
    fi
    
    # Get repository name
    local name
    name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $repo_id;")
    
    echo -e "\n${BLUE}Building with $type using ${PARALLEL_JOBS} parallel jobs...${NC}"
    echo -e "${GRAY}Make flags: $make_flags${NC}"
    echo "Build output will be saved to: $log_file"
    echo "View in terminal: tail -f $log_file"
    
    # Create a subshell to maintain directory state and run the build
    (
        # Unset MAKEFLAGS to prevent -j conflicts with recursive makes
        unset MAKEFLAGS
        # Export CFLAGS if stripping debug
        [ -n "$cflags_extra" ] && export CFLAGS="$cflags_extra" CXXFLAGS="$cflags_extra"
        
        case "$type" in
            "cmake")
                # Create build directory if it doesn't exist
                build_dir="$actual_build_dir/build"
                mkdir -p "$build_dir"
                cd "$build_dir" || exit 1
                
                # Run cmake with progress (add release type if stripping debug)
                local cmake_build_type=""
                [ -n "$cflags_extra" ] && cmake_build_type="-DCMAKE_BUILD_TYPE=Release"
                {
                    cmake ${args[@]:-} $cmake_flags $cmake_build_type .. && \
                    eval "make $make_flags"
                } > "$log_file" 2>&1
                ;;
                
            "autogen")
                cd "$actual_build_dir" || exit 1
                
                # Run autogen.sh, configure, and make
                {
                    echo "Running autogen.sh..." >> "$log_file"
                    ./autogen.sh >> "$log_file" 2>&1 || exit 1
                    
                    echo "Running configure..." >> "$log_file"
                    ./configure ${args[@]:-} $configure_flags >> "$log_file" 2>&1 || exit 1
                    
                    echo "Running make..." >> "$log_file"
                    eval "make $make_flags"
                } > "$log_file" 2>&1
                ;;
                
            "autotools" | "custom-configure")
                cd "$actual_build_dir" || exit 1
                
                # Run configure and make
                {
                    echo "Running configure..." >> "$log_file"
                    ./configure ${args[@]:-} $configure_flags >> "$log_file" 2>&1 || exit 1
                    
                    echo "Running make..." >> "$log_file"
                    eval "make $make_flags"
                } > "$log_file" 2>&1
                ;;
                
            "make")
                cd "$actual_build_dir" || exit 1
                eval "make $make_flags" > "$log_file" 2>&1
                ;;
                
            "gradle")
                cd "$actual_build_dir" || exit 1
                {
                    echo "Running gradle build with ${PARALLEL_JOBS} workers..." >> "$log_file"
                    if [ -x "./gradlew" ]; then
                        echo "Using Gradle wrapper..." >> "$log_file"
                        ./gradlew build --parallel --max-workers=${PARALLEL_JOBS}
                    elif command -v gradle >/dev/null 2>&1; then
                        echo "Using system Gradle..." >> "$log_file"
                        gradle build --parallel --max-workers=${PARALLEL_JOBS}
                    else
                        echo "Error: Neither Gradle wrapper nor system Gradle found" >> "$log_file"
                        exit 1
                    fi
                } > "$log_file" 2>&1
                ;;
                
            "maven")
                cd "$actual_build_dir" || exit 1
                {
                    echo "Running maven build with ${PARALLEL_JOBS} threads..." >> "$log_file"
                    mvn clean install -T ${PARALLEL_JOBS}
                } > "$log_file" 2>&1
                ;;
                
            "python")
                cd "$actual_build_dir" || exit 1
                {
                    echo "Building Python package..." >> "$log_file"
                    python setup.py build
                } > "$log_file" 2>&1
                ;;
                
            "node")
                cd "$actual_build_dir" || exit 1
                {
                    echo "Building Node.js package..." >> "$log_file"
                    npm install && npm run build
                } > "$log_file" 2>&1
                ;;
                
            "meson")
                cd "$actual_build_dir" || exit 1
                {
                    echo "Running meson build with ${PARALLEL_JOBS} jobs..." >> "$log_file"
                    local meson_buildtype=""
                    [ -n "$cflags_extra" ] && meson_buildtype="--buildtype=release"
                    meson build $meson_buildtype && cd build && ninja -j ${PARALLEL_JOBS}
                } > "$log_file" 2>&1
                ;;
                
            *)
                error "Unknown build type: $type"
                exit 1
                ;;
        esac
    ) &
    
    # Get the background process ID
    local pid=$!
    
    # Get previous build duration for this repo (for estimate)
    local prev_duration
    prev_duration=$(sqlite3 "$DB_FILE" "SELECT compile_seconds FROM build_history WHERE repo_id = $repo_id AND success = 0 ORDER BY finished_at DESC LIMIT 1;" 2>/dev/null)
    [ -z "$prev_duration" ] || [ "$prev_duration" = "0" ] && prev_duration=""
    
    # Format previous duration for display
    local prev_duration_str=""
    if [ -n "$prev_duration" ]; then
        prev_duration_str=$(format_duration "$prev_duration")
    fi
    
    # Show progress while building with elapsed time
    local elapsed=0
    local spinner_chars='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local spinner_len=${#spinner_chars}
    
    while kill -0 $pid 2>/dev/null; do
        local spinner_char="${spinner_chars:$((elapsed % spinner_len)):1}"
        local elapsed_str=$(format_duration "$elapsed")
        local log_lines=""
        
        # Get log file line count for activity indicator
        if [ -f "$log_file" ]; then
            log_lines=$(wc -l < "$log_file" 2>/dev/null || echo "0")
        fi
        
        # Build progress line
        local progress_line="${YELLOW}${spinner_char} Building...${NC} ${elapsed_str}"
        
        # Add estimate if we have previous build time
        if [ -n "$prev_duration_str" ]; then
            local remaining=$((prev_duration - elapsed))
            if [ $remaining -gt 0 ]; then
                local remaining_str=$(format_duration "$remaining")
                progress_line="$progress_line ${GRAY}(~${remaining_str} remaining, prev: ${prev_duration_str})${NC}"
            else
                local overtime=$((elapsed - prev_duration))
                local overtime_str=$(format_duration "$overtime")
                progress_line="$progress_line ${GRAY}(+${overtime_str} over prev: ${prev_duration_str})${NC}"
            fi
        fi
        
        # Add log line count
        if [ -n "$log_lines" ] && [ "$log_lines" != "0" ]; then
            progress_line="$progress_line ${GRAY}[${log_lines} lines]${NC}"
        fi
        
        # Clear line and print progress
        echo -ne "\r\033[K${progress_line}"
        
        sleep 1
        ((elapsed++))
    done
    echo -ne "\r\033[K"
    
    # Check if build succeeded
    wait $pid
    local status=$?
    
    # If we used RAM disk, copy results back and cleanup
    if [ "$actual_build_dir" != "$dir" ] && [ "$RAMDISK_ACTIVE" = true ]; then
        if [ $status -eq 0 ]; then
            echo -e "${BLUE}Copying build results from RAM disk...${NC}"
            # Copy back the built files (binaries, libraries, etc.)
            rsync -a --exclude='.git' "$actual_build_dir/" "$dir/" 2>/dev/null || \
                cp -a "$actual_build_dir"/* "$dir/" 2>/dev/null || true
        fi
        # Cleanup RAM disk
        cleanup_ramdisk
    fi
    
    if [ $status -eq 0 ]; then
        echo -e "${GREEN}Build completed successfully!${NC}"
        # Send notification immediately so user knows to respond to prompts
        send_notification "Build Complete" "$name built successfully"
        # Record in build history
        record_build_history "$repo_id" 0 "$log_file" "$build_start_time"
        # Handle post-build prompts (binary selection, launcher, etc.)
        handle_build_result "$repo_id" "$dir" 0 "$log_file"
        return 0
    else
        echo -e "${RED}Build failed!${NC}"
        # Send notification immediately
        send_notification "Build Failed" "$name build failed"
        # Record in build history
        record_build_history "$repo_id" 1 "$log_file" "$build_start_time"
        # Handle post-build prompts (view log, etc.)
        handle_build_result "$repo_id" "$dir" 1 "$log_file"
        return 1
    fi
}

# Detect build system and build package
build_package() {
    local dir="$1"
    local repo_id="$2"
    local build_files=()
    
    # Check if a custom build file path is specified in the database
    local custom_build_file
    custom_build_file=$(sqlite3 "$DB_FILE" "SELECT build_file_path FROM repositories WHERE id = $repo_id;")
    
    if [ -n "$custom_build_file" ] && [ -f "$custom_build_file" ]; then
        echo -e "${BLUE}Using custom build file: $custom_build_file${NC}"
        build_files=("$custom_build_file")
    else
        # If no custom build file, use auto-detection
        build_files=($(find_build_files "$dir" 2))
    fi
    
    if [ ${#build_files[@]} -eq 0 ]; then
        error "No recognized build system found in $dir (searched 2 levels deep)"
        return 1
    fi
    
    if [ ${#build_files[@]} -eq 1 ]; then
        local build_info
        IFS='|' read -r type dir desc <<< "$(get_build_type "${build_files[0]}")"
        echo -e "${GREEN}Detected $desc${NC}"
        execute_build "$type" "$dir" "$repo_id"
    else
        echo -e "\n${BLUE}Multiple build systems detected:${NC}"
        local options=()
        local i=1
        
        for file in "${build_files[@]}"; do
            local type dir desc
            IFS='|' read -r type dir desc <<< "$(get_build_type "$file")"
            if [ -n "$type" ]; then
                echo "$i) $desc (in $dir)"
                options+=("$type|$dir")
                ((i++))
            fi
        done
        
        if [ ${#options[@]} -eq 0 ]; then
            error "No valid build systems found"
            return 1
        elif [ ${#options[@]} -eq 1 ]; then
            echo -e "${GREEN}Using only valid build system found${NC}"
            local selected=(${options[0]//|/ })
            execute_build "${selected[0]}" "${selected[1]}" "$repo_id"
        else
            read -rp "Select build system to use (1-${#options[@]}): " choice
            if [[ $choice =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "${#options[@]}" ]; then
                local selected=(${options[$choice-1]//|/ })
                execute_build "${selected[0]}" "${selected[1]}" "$repo_id"
            else
                error "Invalid selection"
                return 1
            fi
        fi
    fi
}

# Add new repository
add_repo() {
    local name url
    while true; do
        read -rp "Enter repository name (or 'c' to cancel): " name
        if [ "$name" = "c" ]; then
            return 0
        fi
        if [ -z "$name" ]; then
            echo -e "${RED}Name cannot be empty${NC}"
            continue
        fi
        # Check if an active repository with this name exists
        local escaped_name
        escaped_name=$(sql_escape "$name")
        if [ "$(sqlite3 "$DB_FILE" "SELECT COUNT(*) FROM repositories WHERE name = '$escaped_name';")" -gt 0 ]; then
            echo -e "${RED}A repository with this name already exists${NC}"
            continue
        fi
        break
    done
    
    while true; do
        read -rp "Enter GitHub repository URL (or 'c' to cancel): " url
        if [ "$url" = "c" ]; then
            return 0
        fi
        if ! validate_github_url "$url"; then
            continue
        fi
        break
    done
    
    echo -e "\n${BLUE}Fetching repository information...${NC}"
    local commit_date
    commit_date=$(get_last_commit_date "$url")
    
    # Ask about build optimization options
    echo -e "\n${CYAN}Build Options${NC}"
    local strip_debug=0
    read -rp "Strip debug symbols for smaller/faster binaries? (y/N): " strip_choice
    if [[ "$strip_choice" =~ ^[Yy]$ ]]; then
        strip_debug=1
    fi
    
    local use_ramdisk=0
    local available_mb
    available_mb=$(get_available_ram_mb)
    if can_use_ramdisk; then
        echo -e "Available RAM: ${GREEN}${available_mb}MB${NC}"
        read -rp "Use RAM disk for builds when available? (y/N): " ramdisk_choice
        if [[ "$ramdisk_choice" =~ ^[Yy]$ ]]; then
            use_ramdisk=1
        fi
    fi
    
    # Check if we need to rebuild indexes first
    local max_id expected_max_id
    max_id=$(sqlite3 "$DB_FILE" "SELECT MAX(id) FROM repositories;")
    expected_max_id=$(sqlite3 "$DB_FILE" "SELECT COUNT(*) FROM repositories;")
    
    # If there are gaps in the ID sequence, rebuild indexes
    if [ "$max_id" != "$expected_max_id" ]; then
        rebuild_db_indexes
    fi
    
    # Add the new repository - escape values to prevent SQL injection
    local escaped_name escaped_url escaped_commit
    escaped_name=$(sql_escape "$name")
    escaped_url=$(sql_escape "$url")
    escaped_commit=$(sql_escape "$commit_date")
    
    sqlite3 "$DB_FILE" "INSERT INTO repositories (name, url, last_commit) VALUES ('$escaped_name', '$escaped_url', '$escaped_commit');"
    
    # Get the new repository ID and create build config in a transaction
    local new_id
    new_id=$(sqlite3 "$DB_FILE" "SELECT last_insert_rowid();")
    
    db_transaction "INSERT INTO build_configs (repo_id, configure_flags, make_flags, cmake_flags, dependencies, strip_debug, use_ramdisk) VALUES ($new_id, '', '', '', '', $strip_debug, $use_ramdisk);"
    
    success "Repository '$name' added successfully" wait
}

# Edit repository
edit_repo() {
    local id="$1"
    local name url
    
    # Validate ID
    if [[ -z "$id" ]] || ! [[ "$id" =~ ^[0-9]+$ ]]; then
        error "Invalid repository ID: $id"
        return 1
    fi
    
    # Check if repository exists
    local repo_name
    repo_name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $id AND deleted = 0;")
    if [ -z "$repo_name" ]; then
        error "Repository ID $id not found"
        return 1
    fi
    
    echo -e "\n${BLUE}Editing repository: $repo_name (ID: $id)${NC}"
    read -rp "Enter new name (or press enter to skip): " name
    read -rp "Enter new URL (or press enter to skip): " url
    
    local query="UPDATE repositories SET"
    local updates=()
    
    if [ -n "$name" ]; then
        updates+=("name = '$name'")
    fi
    if [ -n "$url" ]; then
        validate_github_url "$url"
        local commit_date
        commit_date=$(get_last_commit_date "$url")
        updates+=("url = '$url'")
        updates+=("last_commit = '$commit_date'")
    fi
    
    if [ ${#updates[@]} -eq 0 ]; then
        error "No changes specified"
        return 1
    fi
    
    # Join updates with commas
    local update_str
    update_str=$(IFS=,; echo "${updates[*]}")
    
    sqlite3 "$DB_FILE" "UPDATE repositories SET $update_str WHERE id = $id AND deleted = 0;"
    success "Repository updated successfully"
}

# Cleanup repository files
cleanup_repo_files() {
    local name="$1"
    local repo_dir="$SRC_DIR/$name"
    
    if [ -d "$repo_dir" ]; then
        echo -e "\n${YELLOW}Found local repository files at: $repo_dir${NC}"
        read -rp "Would you like to remove these files? (y/N): " choice
        if [[ $choice =~ ^[Yy]$ ]]; then
            rm -rf "$repo_dir"
            echo -e "${GREEN}Local repository files removed${NC}"
        fi
    fi
}

# Remove repository
# Rebuild database indexes to ensure sequential IDs
rebuild_db_indexes() {
    echo "Rebuilding database indexes..."
    
    # Create a temporary table with the current data
    sqlite3 "$DB_FILE" <<EOF
    BEGIN TRANSACTION;
    CREATE TEMPORARY TABLE repos_backup AS SELECT * FROM repositories WHERE deleted = 0;
    DELETE FROM repositories;
    DELETE FROM sqlite_sequence WHERE name='repositories';
    INSERT INTO repositories (name, url, last_commit, last_built, build_success, binary_path, created_at, deleted)
    SELECT name, url, last_commit, last_built, build_success, binary_path, created_at, deleted FROM repos_backup;
    DROP TABLE repos_backup;
    COMMIT;
EOF
    
    success "Database indexes rebuilt successfully"
}

remove_repo() {
    local id name
    read -rp "Enter repository ID to remove: " id
    
    # Get repository name before deletion
    name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $id AND deleted = 0;")
    
    if [ -z "$name" ]; then
        error "Repository ID $id not found"
        return 1
    fi
    
    # Hard delete from database
    sqlite3 "$DB_FILE" "DELETE FROM repositories WHERE id = $id;"
    
    # Cleanup local files
    cleanup_repo_files "$name"
    
    # Rebuild indexes to ensure sequential IDs
    rebuild_db_indexes
    
    success "Repository '$name' removed successfully"
}

# Download and build repository
download_build() {
    local id="$1"
    local repo_info
    repo_info=$(sqlite3 "$DB_FILE" "SELECT name, url FROM repositories WHERE id = $id AND deleted = 0;")
    local name url
    name=$(echo "$repo_info" | cut -d'|' -f1)
    url=$(echo "$repo_info" | cut -d'|' -f2)
    
    if [ -z "$name" ]; then
        error "Repository ID $id not found"
        return 1
    fi
    
    # Ensure source directory exists and is accessible
    mkdir -p "$SRC_DIR"
    cd "$SRC_DIR" || {
        error "Failed to access source directory: $SRC_DIR"
        return 1
    }
    
    local repo_dir="$SRC_DIR/$name"
    
    # Track download timing
    local download_start_time download_end_time download_seconds=0 download_size=0
    
    if [ -d "$repo_dir" ]; then
        echo -e "\n${BLUE}Repository already exists locally.${NC}"
        echo "1) Use existing repository and update it"
        echo "2) Clean build cache and rebuild fresh"
        echo "3) Delete existing repository and clone fresh"
        echo "4) Cancel"
        
        read -rp "Select an option: " choice
        case $choice in
            1)
                echo "Updating repository..."
                cd "$repo_dir" || {
                    error "Failed to access repository directory: $repo_dir"
                    return 1
                }
                download_start_time=$(date +%s)
                if ! git pull; then
                    error "Failed to update repository"
                    return 1
                fi
                download_end_time=$(date +%s)
                download_seconds=$((download_end_time - download_start_time))
                ;;
            2)
                echo "Cleaning build cache..."
                clean_build_cache "$repo_dir"
                echo -e "${GREEN}Build cache cleaned. Ready for fresh build.${NC}"
                ;;
            3)
                echo "Deleting existing repository..."
                rm -rf "$repo_dir"
                echo "Cloning repository..."
                download_start_time=$(date +%s)
                if ! git clone "$url" "$name"; then
                    error "Failed to clone repository"
                    return 1
                fi
                download_end_time=$(date +%s)
                download_seconds=$((download_end_time - download_start_time))
                # Calculate download size
                download_size=$(du -sb "$repo_dir" 2>/dev/null | cut -f1)
                ;;
            4)
                echo "Operation cancelled"
                return 0
                ;;
            *)
                error "Invalid option"
                return 1
                ;;
        esac
    else
        echo "Cloning repository..."
        download_start_time=$(date +%s)
        if ! git clone "$url" "$name"; then
            error "Failed to clone repository"
            return 1
        fi
        download_end_time=$(date +%s)
        download_seconds=$((download_end_time - download_start_time))
        # Calculate download size
        download_size=$(du -sb "$repo_dir" 2>/dev/null | cut -f1)
    fi
    
    # Store download metrics for later use in build_package
    export _BUILD_DOWNLOAD_SECONDS="$download_seconds"
    export _BUILD_DOWNLOAD_SIZE="$download_size"
    
    # Check for gitbuildfile and prompt user before using it
    local gitbuildfile="$repo_dir/gitbuildfile"
    if [ -f "$gitbuildfile" ]; then
        echo -e "\n${CYAN}Found gitbuildfile in repository.${NC}"
        read -rp "Use build configuration from gitbuildfile? (Y/n): " use_gitbuildfile
        if [[ ! "$use_gitbuildfile" =~ ^[Nn]$ ]]; then
            parse_gitbuildfile "$repo_dir" "$id"
        else
            echo -e "${YELLOW}Skipping gitbuildfile. Using existing/auto-detected settings...${NC}"
        fi
    fi
    
    # Check for dependencies before building
    if ! check_build_dependencies "$id"; then
        error "Failed to resolve dependencies"
        return 1
    fi
    
    # Offer to backup existing binary before rebuild
    local existing_binary
    existing_binary=$(sqlite3 "$DB_FILE" "SELECT binary_path FROM repositories WHERE id = $id;")
    if [ -n "$existing_binary" ] && [ -f "$existing_binary" ]; then
        echo -e "\n${YELLOW}Existing binary found: $(basename "$existing_binary")${NC}"
        read -rp "Backup existing binary before rebuild? (Y/n): " backup_choice
        if [[ ! "$backup_choice" =~ ^[Nn]$ ]]; then
            backup_binary "$id" "Pre-rebuild backup"
        fi
    fi
    
    echo "Building package..."
    build_package "$repo_dir" "$id"
    
    local current_time
    current_time=$(date -Iseconds)
    sqlite3 "$DB_FILE" "UPDATE repositories SET last_built = '$current_time' WHERE id = $id;"
    
    success "Package built successfully"
}

# Record build type in database
record_build_type() {
    local repo_id="$1"
    local build_type="$2"
    
    sqlite3 "$DB_FILE" "UPDATE repositories SET build_type = '$build_type' WHERE id = $repo_id;"
}

# Show detailed information about a repository
show_build_details() {
    local repo_id="$1"
    
    # Validate repo_id is a number
    if ! [[ "$repo_id" =~ ^[0-9]+$ ]]; then
        error "Invalid repository ID: $repo_id"
        return 1
    fi
    
    while true; do
        show_standard_layout "Repository Details" false
        
        # Get repository details
        local repo_info
        repo_info=$(sqlite3 "$DB_FILE" "SELECT name, url, last_commit, last_commit_check, last_built, 
            build_success, binary_path, build_type, build_file_path, created_at FROM repositories WHERE id = $repo_id;")
        
        if [ -z "$repo_info" ]; then
            error "Repository ID $repo_id not found"
            return 1
        fi
        
        # Parse repository info
        local name url last_commit last_commit_check last_built build_success binary_path build_type build_file_path created_at
        IFS='|' read -r name url last_commit last_commit_check last_built build_success binary_path build_type build_file_path created_at <<< "$repo_info"
        
        # Get build configuration
        local configure_flags make_flags cmake_flags dependencies strip_debug use_ramdisk
        IFS='|' read -r configure_flags make_flags cmake_flags dependencies strip_debug use_ramdisk <<< "$(get_build_config "$repo_id")"
        
        # Format strip_debug and use_ramdisk for display
        local strip_debug_status="${RED}No${NC}"
        [ "$strip_debug" = "1" ] && strip_debug_status="${GREEN}Yes${NC}"
        
        local use_ramdisk_status="${RED}No${NC}"
        [ "$use_ramdisk" = "1" ] && use_ramdisk_status="${GREEN}Yes${NC}"
        
        # Format build success status
        local build_status="Unknown"
        if [ "$build_success" = "0" ]; then
            build_status="${GREEN}Success${NC}"
        elif [ "$build_success" = "1" ]; then
            build_status="${RED}Failed${NC}"
        fi
        
        # Format binary status
        local binary_status="${RED}Not found${NC}"
        if [ -n "$binary_path" ] && [ -x "$binary_path" ]; then
            binary_status="${GREEN}Available${NC}"
        fi
        
        # Format dates nicely
        local formatted_commit_date=""
        if [ -n "$last_commit" ]; then
            formatted_commit_date=$(date -d "$last_commit" "+%Y-%m-%d %H:%M" 2>/dev/null || echo "$last_commit")
        fi
        
        local formatted_commit_check=""
        if [ -n "$last_commit_check" ]; then
            formatted_commit_check=$(date -d "$last_commit_check" "+%Y-%m-%d %H:%M" 2>/dev/null || echo "$last_commit_check")
        fi
        
        local formatted_built_date=""
        if [ -n "$last_built" ]; then
            formatted_built_date=$(date -d "$last_built" "+%Y-%m-%d %H:%M" 2>/dev/null || echo "$last_built")
        fi
        
        local formatted_created_date=""
        if [ -n "$created_at" ]; then
            formatted_created_date=$(date -d "$created_at" "+%Y-%m-%d %H:%M" 2>/dev/null || echo "$created_at")
        fi
        
        # Display repository details as a menu
        echo -e "${YELLOW}GitHub Package Manager - Repository Details (ID: $repo_id)${NC}"
        echo -e "1) ${YELLOW}Name:${NC}              $name"
        echo -e "2) ${YELLOW}URL:${NC}               $url"
        echo -e "3) ${YELLOW}Added on:${NC}          $formatted_created_date (not editable)"
        echo -e "4) ${YELLOW}Last commit:${NC}       $formatted_commit_date (not editable)"
        echo -e "5) ${YELLOW}Commit checked:${NC}    $formatted_commit_check (not editable)"
        echo -e "6) ${YELLOW}Last built:${NC}        $formatted_built_date (not editable)"
        echo -e "7) ${YELLOW}Build status:${NC}      $build_status (not editable)"
        echo -e "8) ${YELLOW}Build type:${NC}        $build_type (not editable)"
        echo -e "9) ${YELLOW}Binary status:${NC}     $binary_status (not editable)"
        echo -e "10) ${YELLOW}Binary path:${NC}       $binary_path"
        echo -e "11) ${YELLOW}Build file path:${NC}   $build_file_path"
        
        echo -e "\n${BLUE}Build Configuration${NC}"
        echo -e "12) ${YELLOW}Configure flags:${NC}   $configure_flags"
        echo -e "13) ${YELLOW}Make flags:${NC}        $make_flags"
        echo -e "14) ${YELLOW}CMake flags:${NC}       $cmake_flags"
        echo -e "15) ${YELLOW}Dependencies:${NC}      $dependencies"
        
        echo -e "\n${BLUE}Build Optimization${NC}"
        echo -e "16) ${YELLOW}Strip debug symbols:${NC} $strip_debug_status"
        echo -e "17) ${YELLOW}Use RAM disk:${NC}        $use_ramdisk_status"
        
        # Get build statistics from build_history
        local build_stats
        build_stats=$(sqlite3 "$DB_FILE" "SELECT duration_seconds, download_seconds, compile_seconds, download_size_bytes FROM build_history WHERE repo_id = $repo_id ORDER BY finished_at DESC LIMIT 1;" 2>/dev/null)
        if [ -n "$build_stats" ]; then
            local last_duration last_download last_compile last_size
            IFS='|' read -r last_duration last_download last_compile last_size <<< "$build_stats"
            
            # Get average build times
            local avg_stats
            avg_stats=$(sqlite3 "$DB_FILE" "SELECT AVG(duration_seconds), AVG(download_seconds), AVG(compile_seconds), COUNT(*) FROM build_history WHERE repo_id = $repo_id AND success = 0;" 2>/dev/null)
            local avg_duration avg_download avg_compile build_count
            IFS='|' read -r avg_duration avg_download avg_compile build_count <<< "$avg_stats"
            
            echo -e "\n${BLUE}Build Statistics${NC}"
            echo -e "    ${YELLOW}Last build duration:${NC}  $(format_duration "${last_duration:-0}")"
            echo -e "    ${YELLOW}  - Download time:${NC}    $(format_duration "${last_download:-0}")"
            echo -e "    ${YELLOW}  - Compile time:${NC}     $(format_duration "${last_compile:-0}")"
            echo -e "    ${YELLOW}  - Download size:${NC}    $(format_bytes "${last_size:-0}")"
            if [ "${build_count:-0}" -gt 1 ]; then
                echo -e "    ${YELLOW}Average build time:${NC}   $(format_duration "${avg_duration%.*}")"
                echo -e "    ${YELLOW}Total builds:${NC}         ${build_count:-0}"
            fi
        fi
        
        # Check if desktop launcher exists for this repo
        local has_launcher=false
        repo_has_desktop_launcher "$repo_id" && has_launcher=true
        
        echo -e "\n${BLUE}Actions${NC}"
        echo -e "18) Rebuild repository"
        echo -e "19) Launch binary"
        echo -e "20) Binary backups"
        echo -e "21) Launch secondary binary"
        if [ "$has_launcher" = true ]; then
            echo -e "22) Remove desktop launcher"
        else
            echo -e "22) Create desktop launcher"
        fi
        echo -e "23) View build errors"
        echo -e "24) View build warnings"
        echo -e "25) View missing dependencies"
        echo -e "26) View full build log"
        echo -e "27) Clear build log files"
        
        # Get user choice with hotkey support (H for help, L for launch)
        echo
        local esc_status=0
        read_with_esc "Select editable option (1-27): " choice "HLG" || esc_status=$?
        
        # Handle hotkeys
        case $esc_status in
            27) return 0 ;;  # Esc - return to main menu
            72) show_help_page; continue ;;  # H - Help
            76) launch_binary "$repo_id"; continue ;;  # L - Quick launch this repo's binary
            71) goto_help_section; continue ;;  # G - Goto help section
        esac
        
        # Handle menu options
        case "$choice" in
            1) # Edit name
                read -rp "Enter new repository name: " new_name
                if [ -n "$new_name" ]; then
                    local escaped_new_name
                    escaped_new_name=$(sql_escape "$new_name")
                    sqlite3 "$DB_FILE" "UPDATE repositories SET name = '$escaped_new_name' WHERE id = $repo_id;"
                    echo -e "${GREEN}Repository name updated${NC}"
                    sleep 1
                fi
                ;;
            2) # Edit URL
                read -rp "Enter new repository URL: " new_url
                if [ -n "$new_url" ]; then
                    local escaped_new_url
                    escaped_new_url=$(sql_escape "$new_url")
                    sqlite3 "$DB_FILE" "UPDATE repositories SET url = '$escaped_new_url' WHERE id = $repo_id;"
                    echo -e "${GREEN}Repository URL updated${NC}"
                    sleep 1
                fi
                ;;
            10) # Edit binary path
                echo -e "${BLUE}Current binary path: $binary_path${NC}"
                echo "1) Browse for binary"
                echo "2) Enter path manually"
                read -rp "Select an option: " binary_choice
                
                case "$binary_choice" in
                    1) # Browse for binary
                        local src_dir="$SRC_DIR/$name"
                        
                        # Debug: Check if directory exists
                        if [ ! -d "$src_dir" ]; then
                            echo -e "${RED}Error: Source directory $src_dir does not exist${NC}"
                            echo -e "${YELLOW}Creating directory...${NC}"
                            mkdir -p "$src_dir"
                            sleep 2
                        fi
                        
                        # Run the file browser directly
                        echo -e "${BLUE}Starting file browser...${NC}"
                        
                        # Call browse_for_binary directly (not capturing output)
                        browse_for_binary "$src_dir" || true
                        
                        # If we get here, the user either selected a binary or quit
                        # Check if a binary path was saved to a temporary file
                        if [ -f "/tmp/gitbuilder_selected_binary" ]; then
                            local selected_binary
                            selected_binary=$(cat "/tmp/gitbuilder_selected_binary")
                            rm -f "/tmp/gitbuilder_selected_binary"
                            
                            if [ -n "$selected_binary" ] && [ -x "$selected_binary" ]; then
                                # Update the database with the selected binary path
                                sqlite3 "$DB_FILE" "UPDATE repositories SET binary_path = '$selected_binary' WHERE id = $repo_id;"
                                echo -e "${GREEN}Binary path updated: $selected_binary${NC}"
                                sleep 2
                            else
                                echo -e "${RED}Error: Selected file is not executable${NC}"
                                sleep 2
                            fi
                        else
                            echo -e "${YELLOW}No binary selected${NC}"
                            sleep 1
                        fi
                        ;;
                    2) # Enter path manually
                        read -rp "Enter new binary path: " new_path
                        if [ -n "$new_path" ]; then
                            # Sanitize and validate path
                            new_path=$(sanitize_path "$new_path")
                            if [ -x "$new_path" ]; then
                                local escaped_path
                                escaped_path=$(sql_escape "$new_path")
                                sqlite3 "$DB_FILE" "UPDATE repositories SET binary_path = '$escaped_path' WHERE id = $repo_id;"
                                echo -e "${GREEN}Binary path updated${NC}"
                                sleep 1
                            else
                                echo -e "${RED}Error: File does not exist or is not executable${NC}"
                                sleep 2
                            fi
                        fi
                        ;;
                    *) 
                        echo -e "${RED}Invalid option${NC}"
                        sleep 1
                        ;;
                esac
                ;;
            11) # Edit build file path
                echo -e "${BLUE}Current build file path: $build_file_path${NC}"
                echo "1) Browse for build file"
                echo "2) Enter path manually"
                read -rp "Select an option: " build_file_choice
                
                case "$build_file_choice" in
                    1) # Browse for build file
                        local src_dir="$SRC_DIR/$name"
                        
                        # Check if directory exists
                        if [ ! -d "$src_dir" ]; then
                            echo -e "${RED}Error: Source directory $src_dir does not exist${NC}"
                            echo -e "${YELLOW}Creating directory...${NC}"
                            mkdir -p "$src_dir"
                            sleep 2
                        fi
                        
                        # Run the file browser directly
                        echo -e "${BLUE}Starting file browser...${NC}"
                        
                        # Call browse_for_binary directly (not capturing output)
                        browse_for_binary "$src_dir" || true
                        
                        # If we get here, the user either selected a file or quit
                        # Check if a file path was saved to a temporary file
                        if [ -f "/tmp/gitbuilder_selected_binary" ]; then
                            local selected_file
                            selected_file=$(cat "/tmp/gitbuilder_selected_binary")
                            rm -f "/tmp/gitbuilder_selected_binary"
                            
                            if [ -n "$selected_file" ] && [ -f "$selected_file" ]; then
                                # Update the database with the selected file path
                                sqlite3 "$DB_FILE" "UPDATE repositories SET build_file_path = '$selected_file' WHERE id = $repo_id;"
                                echo -e "${GREEN}Build file path updated: $selected_file${NC}"
                                sleep 2
                            else
                                echo -e "${RED}Error: Selected file does not exist${NC}"
                                sleep 2
                            fi
                        else
                            echo -e "${YELLOW}No file selected${NC}"
                            sleep 1
                        fi
                        ;;
                    2) # Enter path manually
                        read -rp "Enter new build file path: " new_path
                        if [ -n "$new_path" ]; then
                            # Sanitize and validate path
                            new_path=$(sanitize_path "$new_path")
                            if [ -f "$new_path" ]; then
                                local escaped_path
                                escaped_path=$(sql_escape "$new_path")
                                sqlite3 "$DB_FILE" "UPDATE repositories SET build_file_path = '$escaped_path' WHERE id = $repo_id;"
                                echo -e "${GREEN}Build file path updated${NC}"
                                sleep 1
                            else
                                echo -e "${RED}Error: File does not exist${NC}"
                                sleep 2
                            fi
                        fi
                        ;;
                    *) 
                        echo -e "${RED}Invalid option${NC}"
                        sleep 1
                        ;;
                esac
                ;;
            12) # Edit configure flags
                read -rp "Enter new configure flags: " new_flags
                if [ -n "$new_flags" ] || [ -z "$new_flags" ]; then
                    update_build_config "$repo_id" "configure_flags" "$new_flags"
                    echo -e "${GREEN}Configure flags updated${NC}"
                    sleep 1
                fi
                ;;
            13) # Edit make flags
                read -rp "Enter new make flags: " new_flags
                if [ -n "$new_flags" ] || [ -z "$new_flags" ]; then
                    update_build_config "$repo_id" "make_flags" "$new_flags"
                    echo -e "${GREEN}Make flags updated${NC}"
                    sleep 1
                fi
                ;;
            14) # Edit CMake flags
                read -rp "Enter new CMake flags: " new_flags
                if [ -n "$new_flags" ] || [ -z "$new_flags" ]; then
                    update_build_config "$repo_id" "cmake_flags" "$new_flags"
                    echo -e "${GREEN}CMake flags updated${NC}"
                    sleep 1
                fi
                ;;
            15) # Edit dependencies
                read -rp "Enter software dependencies (space-separated): " new_deps
                if [ -n "$new_deps" ] || [ -z "$new_deps" ]; then
                    update_build_config "$repo_id" "dependencies" "$new_deps"
                    echo -e "${GREEN}Dependencies updated${NC}"
                    sleep 1
                fi
                ;;
            16) # Toggle strip debug symbols
                if [ "$strip_debug" = "1" ]; then
                    update_build_config "$repo_id" "strip_debug" "0"
                    echo -e "${GREEN}Debug symbols will be kept${NC}"
                else
                    update_build_config "$repo_id" "strip_debug" "1"
                    echo -e "${GREEN}Debug symbols will be stripped (smaller/faster binaries)${NC}"
                fi
                sleep 1
                ;;
            17) # Toggle use RAM disk
                if [ "$use_ramdisk" = "1" ]; then
                    update_build_config "$repo_id" "use_ramdisk" "0"
                    echo -e "${GREEN}RAM disk disabled for builds${NC}"
                else
                    local available_mb
                    available_mb=$(get_available_ram_mb)
                    if can_use_ramdisk; then
                        update_build_config "$repo_id" "use_ramdisk" "1"
                        echo -e "${GREEN}RAM disk enabled for builds (${available_mb}MB available)${NC}"
                    else
                        echo -e "${RED}Insufficient RAM available (${available_mb}MB, need ${RAMDISK_MIN_FREE_MB}MB)${NC}"
                    fi
                fi
                sleep 1
                ;;
            18) # Rebuild repository
                printf "\033c"
                echo -e "${BLUE}Rebuilding repository $name...${NC}"
                download_build "$repo_id" "rebuild"
                echo -e "\n${GREEN}Rebuild complete${NC}"
                sleep 2
                ;;
            19) # Launch binary
                printf "\033c"
                launch_binary "$repo_id"
                echo -e "\n${GREEN}Press any key to continue...${NC}"
                read -r -n 1
                ;;
            20) # Binary backups
                binary_backups_menu "$repo_id"
                ;;
            21) # Launch secondary binary
                launch_secondary_binary_menu "$repo_id"
                ;;
            22) # Create/Remove desktop launcher
                if [ "$has_launcher" = true ]; then
                    delete_desktop_launcher "$repo_id"
                else
                    create_desktop_launcher "$repo_id"
                fi
                ;;
            23) # View build errors
                view_build_log_filtered "$repo_id" "errors"
                ;;
            24) # View build warnings
                view_build_log_filtered "$repo_id" "warnings"
                ;;
            25) # View missing dependencies
                view_build_log_filtered "$repo_id" "missing_deps"
                ;;
            26) # View full build log
                view_full_build_log "$repo_id"
                ;;
            27) # Clear build log files
                clear_build_log_files "$repo_id"
                ;;
            *) 
                echo -e "${RED}Invalid option${NC}"
                sleep 1
                ;;
        esac
    done
}

# View full build log for a repository
view_full_build_log() {
    local repo_id="$1"
    
    # Get the most recent log file
    local log_file
    log_file=$(sqlite3 "$DB_FILE" "SELECT log_file FROM build_history WHERE repo_id = $repo_id ORDER BY finished_at DESC LIMIT 1;" 2>/dev/null)
    
    if [ -z "$log_file" ] || [ ! -f "$log_file" ]; then
        echo -e "${YELLOW}No build log found for this repository.${NC}"
        read -rp "Press Enter to continue..."
        return 1
    fi
    
    less "$log_file"
}

# Clear build log files for a repository (keeps database records)
clear_build_log_files() {
    local repo_id="$1"
    
    # Get repository name
    local repo_name
    repo_name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $repo_id;" 2>/dev/null)
    
    # Get all log files for this repository
    local log_files
    log_files=$(sqlite3 "$DB_FILE" "SELECT log_file FROM build_history WHERE repo_id = $repo_id AND log_file IS NOT NULL;" 2>/dev/null)
    
    if [ -z "$log_files" ]; then
        echo -e "${YELLOW}No build logs found for this repository.${NC}"
        read -rp "Press Enter to continue..."
        return 1
    fi
    
    # Count log files
    local log_count=0
    local total_size=0
    while IFS= read -r log_file; do
        if [ -f "$log_file" ]; then
            ((log_count++)) || true
            local file_size
            file_size=$(stat -c%s "$log_file" 2>/dev/null || echo 0)
            total_size=$((total_size + file_size))
        fi
    done <<< "$log_files"
    
    if [ "$log_count" -eq 0 ]; then
        echo -e "${YELLOW}No build log files found on disk.${NC}"
        read -rp "Press Enter to continue..."
        return 1
    fi
    
    echo -e "${BLUE}Clear Build Log Files${NC}"
    echo "============================================"
    echo -e "Repository: ${CYAN}$repo_name${NC}"
    echo -e "Log files found: ${YELLOW}$log_count${NC}"
    echo -e "Total size: ${YELLOW}$(format_bytes $total_size)${NC}"
    echo ""
    echo -e "${YELLOW}Note: This will delete log files from disk but keep build history records in the database.${NC}"
    echo ""
    
    read -rp "Delete all log files for this repository? (y/N): " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}Operation cancelled${NC}"
        read -rp "Press Enter to continue..."
        return 0
    fi
    
    # Delete the log files
    local deleted=0
    while IFS= read -r log_file; do
        if [ -f "$log_file" ]; then
            if rm -f "$log_file" 2>/dev/null; then
                ((deleted++)) || true
            fi
        fi
    done <<< "$log_files"
    
    # Also try to clean up empty log directories
    local repo_dir
    repo_dir=$(sqlite3 "$DB_FILE" "SELECT url FROM repositories WHERE id = $repo_id;" 2>/dev/null)
    repo_dir="$SRC_DIR/$repo_name/logs"
    if [ -d "$repo_dir" ] && [ -z "$(ls -A "$repo_dir" 2>/dev/null)" ]; then
        rmdir "$repo_dir" 2>/dev/null || true
    fi
    
    echo -e "${GREEN}Deleted $deleted log file(s)${NC}"
    read -rp "Press Enter to continue..."
}

# View build log filtered for errors, warnings, or missing dependencies
view_build_log_filtered() {
    local repo_id="$1"
    local filter_type="$2"
    
    # Get the most recent log file
    local log_file
    log_file=$(sqlite3 "$DB_FILE" "SELECT log_file FROM build_history WHERE repo_id = $repo_id ORDER BY finished_at DESC LIMIT 1;" 2>/dev/null)
    
    if [ -z "$log_file" ] || [ ! -f "$log_file" ]; then
        echo -e "${YELLOW}No build log found for this repository.${NC}"
        read -rp "Press Enter to continue..."
        return 1
    fi
    
    clear
    local title pattern
    case "$filter_type" in
        "errors")
            title="Build Errors"
            # Common error patterns across build systems
            pattern="error:|Error:|ERROR:|fatal:|FATAL:|undefined reference|cannot find|No such file|failed|FAILED|make\[.*\]: \*\*\*"
            ;;
        "warnings")
            title="Build Warnings"
            # Common warning patterns
            pattern="warning:|Warning:|WARNING:|deprecated|DEPRECATED"
            ;;
        "missing_deps")
            title="Missing Dependencies"
            # Patterns for missing packages/libraries
            pattern="Package .* was not found|could not find|not found|No package .* found|cannot find -l|missing:|requires|dependency|configure: error:|CMake Error.*find_package|unable to locate"
            ;;
        *)
            title="Build Log"
            pattern="."
            ;;
    esac
    
    echo -e "${BLUE}$title${NC}"
    echo "============================================"
    echo -e "Log file: ${CYAN}$log_file${NC}"
    echo ""
    
    local matches
    matches=$(grep -iE "$pattern" "$log_file" 2>/dev/null | head -100)
    
    if [ -z "$matches" ]; then
        echo -e "${GREEN}No $filter_type found in the build log.${NC}"
    else
        echo -e "${YELLOW}Found the following $filter_type:${NC}"
        echo ""
        echo "$matches" | while IFS= read -r line; do
            # Colorize based on type
            case "$filter_type" in
                "errors")
                    echo -e "${RED}$line${NC}"
                    ;;
                "warnings")
                    echo -e "${YELLOW}$line${NC}"
                    ;;
                "missing_deps")
                    echo -e "${MAGENTA}$line${NC}"
                    ;;
                *)
                    echo "$line"
                    ;;
            esac
        done
        
        local count
        count=$(grep -ciE "$pattern" "$log_file" 2>/dev/null || echo "0")
        echo ""
        echo -e "${GRAY}Showing up to 100 of $count matches${NC}"
    fi
    
    echo ""
    read -rp "Press Enter to continue (or 'v' to view full log): " view_choice
    if [[ "$view_choice" =~ ^[Vv]$ ]]; then
        less "$log_file"
    fi
}

# Display repositories table with full date format
show_repos() {
    fetch_repo_data "full"
    render_table "Available Repositories:" "2|8|10|10|10|6|3"
}

# Launch binary
launch_binary() {
    local repo_id="$1"
    
    # Get repository info from database
    local binary_path name
    IFS='|' read -r binary_path name <<< $(sqlite3 "$DB_FILE" "SELECT binary_path, name FROM repositories WHERE id = $repo_id;")
    
    # Check if we got valid data
    if [ -z "$name" ]; then
        error "Could not find repository data"
        return 1
    fi
    
    # Construct source directory path
    local src_dir="$SRC_DIR/$name"
    
    # If no binary is registered, try to find one
    if [ -z "$binary_path" ] || [ ! -x "$binary_path" ]; then
        echo -e "${YELLOW}No binary registered or binary not found. Searching for binaries...${NC}"
        
        # Look for binaries
        echo -e "\n${BLUE}Looking for binary files...${NC}"
        local binaries=()
        # Capture each line of output as a separate array element
        mapfile -t binaries < <(find_binary "$src_dir" "$name")
        
        if [ ${#binaries[@]} -gt 0 ]; then
            echo -e "\n${BLUE}Found potential binary files:${NC}"
            echo ""
            local i=1
            for binary in "${binaries[@]}"; do
                echo "$i) $binary"
                ((i++))
            done
            
            echo "b) Browse for binary"
            local choice
            echo ""
            read -rp "Select binary to register (1-${#binaries[@]}, or 'b' to browse): " choice
            
            if [[ $choice =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "${#binaries[@]}" ]; then
                binary_path="${binaries[$((choice-1))]}"
            elif [[ $choice == "b" ]]; then
                # Clear the screen before calling the browser to avoid display issues
                printf "\033c"
                # Call the browse_for_binary function directly (not in subshell)
                local browse_status=0
                browse_for_binary "$src_dir" || browse_status=$?
                # Clear the screen again after returning from the browser
                printf "\033c"
                if [ $browse_status -ne 0 ]; then
                    echo -e "${YELLOW}Binary selection cancelled${NC}"
                    return 1
                fi
                
                # Read the selected binary from temp file
                if [ -f "/tmp/gitbuilder_selected_file" ]; then
                    binary_path=$(cat "/tmp/gitbuilder_selected_file")
                    rm -f "/tmp/gitbuilder_selected_file"
                else
                    echo -e "${RED}Error: No binary selected${NC}"
                    return 1
                fi
                
                # Verify the selected binary exists and is executable
                if [ ! -x "$binary_path" ]; then
                    echo -e "${RED}Error: Selected binary is not executable${NC}"
                    return 1
                fi
            else
                return 1
            fi
            
            # Save the selected binary path
            sqlite3 "$DB_FILE" "UPDATE repositories SET binary_path = '$binary_path' WHERE id = $repo_id;"
            echo -e "${GREEN}Binary registered: $binary_path${NC}"
        else
            echo -e "${YELLOW}No binaries found automatically.${NC}"
            local browse_choice
            read -rp "Would you like to browse for the binary? (Y/n): " browse_choice
            if [[ ! $browse_choice =~ ^[Nn]$ ]]; then
                # Clear the screen before calling the browser to avoid display issues
                printf "\033c"
                # Call the browse_for_binary function directly (not in subshell)
                local browse_status=0
                browse_for_binary "$src_dir" || browse_status=$?
                # Clear the screen again after returning from the browser
                printf "\033c"
                if [ $browse_status -ne 0 ]; then
                    echo -e "${YELLOW}Binary selection cancelled${NC}"
                    return 1
                fi
                
                # Read the selected binary from temp file
                if [ -f "/tmp/gitbuilder_selected_file" ]; then
                    binary_path=$(cat "/tmp/gitbuilder_selected_file")
                    rm -f "/tmp/gitbuilder_selected_file"
                else
                    echo -e "${RED}Error: No binary selected${NC}"
                    return 1
                fi
                
                # Verify the selected binary exists and is executable
                if [ ! -x "$binary_path" ]; then
                    echo -e "${RED}Error: Selected binary is not executable${NC}"
                    return 1
                fi
                
                # Save the selected binary path
                sqlite3 "$DB_FILE" "UPDATE repositories SET binary_path = '$binary_path' WHERE id = $repo_id;"
                echo -e "${GREEN}Binary registered: $binary_path${NC}"
            else
                return 1
            fi
        fi
    fi
    
    # Ask for launch mode
    echo -e "\n${GREEN}Launch Options:${NC}"
    echo "1) Quiet (run in background)"
    echo "2) Verbose (show output)"
    
    local launch_mode
    read -rp "Select launch mode (1-2): " launch_mode
    
    case $launch_mode in
        1)
            echo -e "\n${BLUE}Launching binary in background: $binary_path${NC}"
            nohup "$binary_path" > /dev/null 2>&1 &
            echo -e "${GREEN}Binary launched! You can continue using gitbuilder.${NC}"
            ;;
        2)
            echo -e "\n${BLUE}Launching binary with output: $binary_path${NC}"
            "$binary_path"
            ;;
        *)
            error "Invalid launch mode"
            return 1
            ;;
    esac
}

# Save build configuration to gitbuildfile
save_gitbuildfile() {
    local repo_id="$1"
    
    # Get repository information
    local repo_info
    repo_info=$(sqlite3 "$DB_FILE" "SELECT name, url, build_type, build_file_path, binary_path FROM repositories WHERE id = $repo_id;")
    
    if [ -z "$repo_info" ]; then
        error "Repository ID $repo_id not found"
        return 1
    fi
    
    local name url build_type build_file_path binary_path
    name=$(echo "$repo_info" | cut -d'|' -f1)
    url=$(echo "$repo_info" | cut -d'|' -f2)
    build_type=$(echo "$repo_info" | cut -d'|' -f3)
    build_file_path=$(echo "$repo_info" | cut -d'|' -f4)
    binary_path=$(echo "$repo_info" | cut -d'|' -f5)
    
    # Get build configuration - use cut to extract specific fields to handle any corrupted data
    local build_config
    build_config=$(get_build_config "$repo_id")
    local configure_flags make_flags cmake_flags dependencies
    configure_flags=$(echo "$build_config" | cut -d'|' -f1)
    make_flags=$(echo "$build_config" | cut -d'|' -f2)
    cmake_flags=$(echo "$build_config" | cut -d'|' -f3)
    dependencies=$(echo "$build_config" | cut -d'|' -f4)
    
    # Get notes
    local notes
    notes=$(sqlite3 "$DB_FILE" "SELECT notes FROM repository_notes WHERE repo_id = $repo_id;" || echo "")
    
    # Get desktop launcher settings
    local launcher_info
    launcher_info=$(sqlite3 "$DB_FILE" "SELECT icon_path, menu_category FROM desktop_launchers WHERE repo_id = $repo_id;" || echo "")
    local launcher_icon launcher_category
    launcher_icon=$(echo "$launcher_info" | cut -d'|' -f1)
    launcher_category=$(echo "$launcher_info" | cut -d'|' -f2)
    
    echo -e "\n${BLUE}Saving gitbuildfile for $name${NC}"
    
    # Check if repository exists locally
    local repo_dir="$SRC_DIR/$name"
    if [ ! -d "$repo_dir" ]; then
        echo -e "${YELLOW}Repository not found locally at $repo_dir${NC}"
        echo "Would you like to clone it first?"
        read -rp "Clone repository? (y/N): " clone_choice
        if [[ $clone_choice =~ ^[Yy]$ ]]; then
            echo "Cloning repository..."
            if ! git clone "$url" "$repo_dir"; then
                error "Failed to clone repository"
                return 1
            fi
        else
            echo -e "${YELLOW}Saving gitbuildfile to current directory instead${NC}"
            repo_dir="."
        fi
    fi
    
    # Replace home directory path with ~ for portability
    build_file_path="${build_file_path/#$HOME/\~}"
    binary_path="${binary_path/#$HOME/\~}"
    launcher_icon="${launcher_icon/#$HOME/\~}"
    
    # Create gitbuildfile content
    local gitbuildfile_content="# GitBuilder build configuration file
# Generated automatically by GitBuilder

# Repository information
REPO_NAME=\"$name\"
REPO_URL=\"$url\"

# Build method (cmake, autotools, make, etc.)
BUILD_METHOD=\"$build_type\"

# Space-separated list of dependencies
DEPENDENCIES=\"$dependencies\"

# Path to the build file (relative to repo root or absolute)
BUILD_FILE=\"$build_file_path\"

# Configure flags for autotools/cmake
CONFIGURE_FLAGS=\"$configure_flags\"

# Make flags
MAKE_FLAGS=\"$make_flags\"

# CMake flags
CMAKE_FLAGS=\"$cmake_flags\"

# Path to the compiled binary (relative to repo root or absolute)
BINARY_PATH=\"$binary_path\"

# Desktop launcher settings
LAUNCHER_ICON=\"$launcher_icon\"
LAUNCHER_CATEGORY=\"$launcher_category\"

# Repository notes (displayed after build)
NOTES=\"$notes\"
"
    
    # Write gitbuildfile
    local gitbuildfile_path="$repo_dir/gitbuildfile"
    local gitbuildfiles_copy="$GITBUILDFILES_DIR/gitbuildfile-$name"
    
    # Check if either file exists and prompt once for overwrite
    local files_exist=false
    if [ -f "$gitbuildfile_path" ]; then
        echo -e "${YELLOW}gitbuildfile already exists at: $gitbuildfile_path${NC}"
        files_exist=true
    fi
    if [ -f "$gitbuildfiles_copy" ]; then
        echo -e "${YELLOW}Backup copy already exists at: $gitbuildfiles_copy${NC}"
        files_exist=true
    fi
    
    if [ "$files_exist" = true ]; then
        read -rp "Overwrite existing file(s)? (y/N): " overwrite_choice
        if [[ ! "$overwrite_choice" =~ ^[Yy]$ ]]; then
            echo -e "${YELLOW}Save cancelled${NC}"
            read -rp "Press Enter to continue..."
            return 0
        fi
    fi
    
    # Use >| to force overwrite even with noclobber set
    echo "$gitbuildfile_content" >| "$gitbuildfile_path"
    
    if [ $? -eq 0 ]; then
        success "gitbuildfile saved to $gitbuildfile_path" wait
        
        # Also save a copy to gitbuildfiles directory
        cp "$gitbuildfile_path" "$gitbuildfiles_copy" 2>/dev/null
        echo -e "${CYAN}Copy saved to: $gitbuildfiles_copy${NC}"
    else
        error "Failed to save gitbuildfile"
        return 1
    fi
}

# Save gitbuildfiles for all repositories
save_all_gitbuildfiles() {
    echo -e "\n${BLUE}Save gitbuildfiles for all repositories${NC}"
    echo "============================================"
    
    # Get all repository IDs and names
    local repos
    repos=$(sqlite3 "$DB_FILE" "SELECT id, name FROM repositories WHERE deleted = 0 ORDER BY name;")
    
    if [ -z "$repos" ]; then
        echo -e "${YELLOW}No repositories found${NC}"
        read -rp "Press Enter to continue..."
        return 1
    fi
    
    local count=0
    local total=0
    local failed=0
    
    # Count total repos
    total=$(echo "$repos" | wc -l)
    
    echo -e "Found ${GREEN}$total${NC} repositories"
    echo ""
    read -rp "Save gitbuildfiles for all repositories? (y/N): " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        read -rp "Press Enter to continue..."
        return 0
    fi
    
    echo ""
    
    while IFS='|' read -r repo_id repo_name; do
        echo -e "${CYAN}Processing: $repo_name${NC}"
        
        # Get repository info
        local repo_info
        repo_info=$(sqlite3 "$DB_FILE" "SELECT name, url, build_type, build_file_path, binary_path FROM repositories WHERE id = $repo_id;")
        
        local name url build_type build_file_path binary_path
        name=$(echo "$repo_info" | cut -d'|' -f1)
        url=$(echo "$repo_info" | cut -d'|' -f2)
        build_type=$(echo "$repo_info" | cut -d'|' -f3)
        build_file_path=$(echo "$repo_info" | cut -d'|' -f4)
        binary_path=$(echo "$repo_info" | cut -d'|' -f5)
        
        # Get build configuration
        local build_config
        build_config=$(get_build_config "$repo_id")
        local configure_flags make_flags cmake_flags dependencies
        configure_flags=$(echo "$build_config" | cut -d'|' -f1)
        make_flags=$(echo "$build_config" | cut -d'|' -f2)
        cmake_flags=$(echo "$build_config" | cut -d'|' -f3)
        dependencies=$(echo "$build_config" | cut -d'|' -f4)
        
        # Get notes
        local notes
        notes=$(sqlite3 "$DB_FILE" "SELECT notes FROM repository_notes WHERE repo_id = $repo_id;" || echo "")
        
        # Get desktop launcher settings
        local launcher_info
        launcher_info=$(sqlite3 "$DB_FILE" "SELECT icon_path, menu_category FROM desktop_launchers WHERE repo_id = $repo_id;" || echo "")
        local launcher_icon launcher_category
        launcher_icon=$(echo "$launcher_info" | cut -d'|' -f1)
        launcher_category=$(echo "$launcher_info" | cut -d'|' -f2)
        
        # Replace home directory path with ~ for portability
        build_file_path="${build_file_path/#$HOME/\~}"
        binary_path="${binary_path/#$HOME/\~}"
        launcher_icon="${launcher_icon/#$HOME/\~}"
        
        # Create gitbuildfile content
        local gitbuildfile_content="# GitBuilder build configuration file
# Generated automatically by GitBuilder

# Repository information
REPO_NAME=\"$name\"
REPO_URL=\"$url\"

# Build method (cmake, autotools, make, etc.)
BUILD_METHOD=\"$build_type\"

# Space-separated list of dependencies
DEPENDENCIES=\"$dependencies\"

# Path to the build file (relative to repo root or absolute)
BUILD_FILE=\"$build_file_path\"

# Configure flags for autotools/cmake
CONFIGURE_FLAGS=\"$configure_flags\"

# Make flags
MAKE_FLAGS=\"$make_flags\"

# CMake flags
CMAKE_FLAGS=\"$cmake_flags\"

# Path to the compiled binary (relative to repo root or absolute)
BINARY_PATH=\"$binary_path\"

# Desktop launcher settings
LAUNCHER_ICON=\"$launcher_icon\"
LAUNCHER_CATEGORY=\"$launcher_category\"

# Repository notes (displayed after build)
NOTES=\"$notes\"
"
        
        # Save to gitbuildfiles directory only (don't require local repo)
        local gitbuildfiles_copy="$GITBUILDFILES_DIR/gitbuildfile-$name"
        
        if echo "$gitbuildfile_content" >| "$gitbuildfiles_copy" 2>/dev/null; then
            echo -e "  ${GREEN}✓${NC} Saved to $gitbuildfiles_copy"
            ((count++))
        else
            echo -e "  ${RED}✗${NC} Failed to save"
            ((failed++))
        fi
    done <<< "$repos"
    
    echo ""
    echo "============================================"
    echo -e "${GREEN}Saved: $count${NC} | ${RED}Failed: $failed${NC} | Total: $total"
    read -rp "Press Enter to continue..."
}

# Import gitbuildfile from gitbuildfiles directory
import_gitbuildfile() {
    echo -e "\n${BLUE}Import gitbuildfile${NC}"
    echo -e "Gitbuildfiles directory: ${CYAN}$GITBUILDFILES_DIR${NC}\n"
    
    # Check if there are any gitbuildfiles
    local file_count
    file_count=$(find "$GITBUILDFILES_DIR" -maxdepth 1 -type f -name "gitbuildfile*" 2>/dev/null | wc -l)
    
    if [ "$file_count" -eq 0 ]; then
        echo -e "${YELLOW}No gitbuildfiles found in $GITBUILDFILES_DIR${NC}"
        echo -e "You can:"
        echo -e "  1) Save a gitbuildfile from an existing repository (menu option 8)"
        echo -e "  2) Manually place gitbuildfile files in: $GITBUILDFILES_DIR"
        echo -e "\nPress any key to continue..."
        read -r -n 1
        return 1
    fi
    
    # Use file browser to select a gitbuildfile
    printf "\033c"
    file_browser "$GITBUILDFILES_DIR" "gitbuildfile"
    local browse_status=$?
    printf "\033c"
    
    if [ $browse_status -ne 0 ]; then
        echo -e "${YELLOW}Import cancelled${NC}"
        sleep 1
        return 1
    fi
    
    # Get selected file
    local selected_file
    selected_file=$(cat /tmp/gitbuilder_selected_file 2>/dev/null)
    
    if [ -z "$selected_file" ] || [ ! -f "$selected_file" ]; then
        error "No file selected"
        return 1
    fi
    
    echo -e "${BLUE}Importing: $selected_file${NC}\n"
    
    # Parse the gitbuildfile
    local repo_name="" build_method="" dependencies="" build_file=""
    local configure_flags="" make_flags="" cmake_flags="" binary_path="" notes=""
    local repo_url=""
    
    while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue
        
        # Remove quotes from value
        value="${value#\"}"
        value="${value%\"}"
        value="${value#\'}"
        value="${value%\'}"
        
        case "$key" in
            REPO_NAME) repo_name="$value" ;;
            REPO_URL) repo_url="$value" ;;
            BUILD_METHOD) build_method="$value" ;;
            DEPENDENCIES) dependencies="$value" ;;
            BUILD_FILE) build_file="$value" ;;
            CONFIGURE_FLAGS) configure_flags="$value" ;;
            MAKE_FLAGS) make_flags="$value" ;;
            CMAKE_FLAGS) cmake_flags="$value" ;;
            BINARY_PATH) binary_path="$value" ;;
            NOTES) notes="$value" ;;
        esac
    done < "$selected_file"
    
    # Display parsed information
    echo -e "${CYAN}Parsed gitbuildfile:${NC}"
    echo -e "  Repository name: ${GREEN}$repo_name${NC}"
    [ -n "$repo_url" ] && echo -e "  Repository URL:  ${GREEN}$repo_url${NC}"
    echo -e "  Build method:    ${GREEN}$build_method${NC}"
    echo -e "  Dependencies:    ${GREEN}$dependencies${NC}"
    echo -e "  Build file:      ${GREEN}$build_file${NC}"
    echo -e "  Configure flags: ${GREEN}$configure_flags${NC}"
    echo -e "  Make flags:      ${GREEN}$make_flags${NC}"
    echo -e "  CMake flags:     ${GREEN}$cmake_flags${NC}"
    echo -e "  Binary path:     ${GREEN}$binary_path${NC}"
    [ -n "$notes" ] && echo -e "  Notes:           ${GREEN}$notes${NC}"
    echo
    
    # Check if repository already exists
    local existing_id
    existing_id=$(sqlite3 "$DB_FILE" "SELECT id FROM repositories WHERE name = '$repo_name' LIMIT 1;" 2>/dev/null)
    
    if [ -n "$existing_id" ]; then
        echo -e "${YELLOW}Repository '$repo_name' already exists (ID: $existing_id)${NC}"
        read -rp "Update existing repository with this configuration? (y/N): " update_choice
        
        if [[ ! "$update_choice" =~ ^[Yy]$ ]]; then
            echo -e "${YELLOW}Import cancelled${NC}"
            sleep 1
            return 1
        fi
        
        # Update existing repository
        sqlite3 "$DB_FILE" "UPDATE repositories SET build_type = '$build_method', build_file_path = '$build_file', binary_path = '$binary_path' WHERE id = $existing_id;"
        
        # Update build config
        update_build_config "$existing_id" "configure_flags" "$configure_flags"
        update_build_config "$existing_id" "make_flags" "$make_flags"
        update_build_config "$existing_id" "cmake_flags" "$cmake_flags"
        update_build_config "$existing_id" "dependencies" "$dependencies"
        
        # Update notes if provided
        if [ -n "$notes" ]; then
            sqlite3 "$DB_FILE" "INSERT OR REPLACE INTO repository_notes (repo_id, notes) VALUES ($existing_id, '$notes');"
        fi
        
        success "Repository '$repo_name' updated with imported configuration" wait
    else
        # Need URL for new repository
        if [ -z "$repo_url" ]; then
            echo -e "${YELLOW}No repository URL found in gitbuildfile${NC}"
            read -rp "Enter GitHub repository URL: " repo_url
            
            if [ -z "$repo_url" ]; then
                error "URL is required to add a new repository"
                return 1
            fi
            
            if ! validate_github_url "$repo_url"; then
                return 1
            fi
        fi
        
        read -rp "Add this as a new repository? (Y/n): " add_choice
        
        if [[ "$add_choice" =~ ^[Nn]$ ]]; then
            echo -e "${YELLOW}Import cancelled${NC}"
            sleep 1
            return 1
        fi
        
        # Add new repository
        echo -e "\n${BLUE}Fetching repository information...${NC}"
        local commit_date
        commit_date=$(get_last_commit_date "$repo_url")
        
        # Insert repository first to get the ID
        sqlite3 "$DB_FILE" "INSERT INTO repositories (name, url, last_commit, build_type, build_file_path, binary_path) VALUES ('$repo_name', '$repo_url', '$commit_date', '$build_method', '$build_file', '$binary_path');"
        
        # Get the new repository ID
        local new_id
        new_id=$(sqlite3 "$DB_FILE" "SELECT last_insert_rowid();")
        
        # Build remaining SQL statements for transaction
        local sql="INSERT INTO build_configs (repo_id, configure_flags, make_flags, cmake_flags, dependencies) VALUES ($new_id, '$configure_flags', '$make_flags', '$cmake_flags', '$dependencies');"
        
        # Add notes if provided
        if [ -n "$notes" ]; then
            sql+=" INSERT INTO repository_notes (repo_id, notes) VALUES ($new_id, '$notes');"
        fi
        
        # Execute remaining inserts in a single transaction
        if db_transaction "$sql"; then
            success "Repository '$repo_name' added from gitbuildfile (ID: $new_id)" wait
        else
            error "Failed to import repository"
            return 1
        fi
    fi
    
    return 0
}

# Repository notes menu
repository_notes_menu() {
    while true; do
        show_standard_layout "Repository Notes"
        local current_editor
        current_editor=$(get_editor)
        
        echo -e "Editor: ${GREEN}${current_editor:-none}${NC}"
        echo ""
        echo "1) Read notes"
        echo "2) Edit notes"
        echo "3) Change editor"
        
        echo ""
        local esc_status=0
        read_with_esc "Select option: " choice "HG" || esc_status=$?
        
        # Handle hotkeys
        case $esc_status in
            27) return 0 ;;  # Esc - return to main menu
            72) show_help_page; continue ;;  # H - Help
            71) goto_help_section; continue ;;  # G - Goto help section
        esac
        
        # Handle menu options
        case $choice in
            1) 
                read_repository_notes
                ;;
            2)
                edit_repository_notes
                ;;
            3)
                change_editor
                ;;
            *) 
                echo -e "${RED}Invalid option${NC}"
                sleep 1
                ;;
        esac
    done
}

# Read repository notes
read_repository_notes() {
    read -rp "Enter repository ID: " repo_id
    
    # Validate ID
    if [[ -z "$repo_id" ]] || ! [[ "$repo_id" =~ ^[0-9]+$ ]]; then
        error "Invalid repository ID: $repo_id"
        return 1
    fi
    
    # Get repository name
    local repo_name
    repo_name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $repo_id;" || echo "")
    
    if [ -z "$repo_name" ]; then
        error "Repository ID $repo_id not found"
        return 1
    fi
    
    # Get notes
    local notes
    notes=$(sqlite3 "$DB_FILE" "SELECT notes FROM repository_notes WHERE repo_id = $repo_id;" || echo "")
    
    echo -e "\n${BLUE}Notes for $repo_name (ID: $repo_id)${NC}"
    echo "=========================================="
    
    if [ -z "$notes" ]; then
        echo -e "${YELLOW}No notes found for this repository${NC}"
    else
        echo "$notes"
    fi
    
    echo "=========================================="
    echo -e "\nPress any key to continue..."
    read -r -n 1
}

# Edit repository notes
edit_repository_notes() {
    read -rp "Enter repository ID: " repo_id
    
    # Validate ID
    if [[ -z "$repo_id" ]] || ! [[ "$repo_id" =~ ^[0-9]+$ ]]; then
        error "Invalid repository ID: $repo_id"
        return 1
    fi
    
    # Get repository name
    local repo_name
    repo_name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $repo_id;" || echo "")
    
    if [ -z "$repo_name" ]; then
        error "Repository ID $repo_id not found"
        return 1
    fi
    
    # Get current notes
    local current_notes
    current_notes=$(sqlite3 "$DB_FILE" "SELECT notes FROM repository_notes WHERE repo_id = $repo_id;" || echo "")
    
    echo -e "\n${BLUE}Editing notes for $repo_name (ID: $repo_id)${NC}"
    echo "Current notes:"
    echo "=========================================="
    if [ -z "$current_notes" ]; then
        echo -e "${YELLOW}No current notes${NC}"
    else
        echo "$current_notes"
    fi
    echo "=========================================="
    
    # Create temporary file for editing
    local temp_file
    temp_file=$(mktemp --suffix=.txt)
    # Use >| to force write even with noclobber set
    if [ -n "$current_notes" ]; then
        echo "$current_notes" >| "$temp_file"
    fi
    
    # Get preferred editor
    local editor
    editor=$(get_editor)
    
    if [ -n "$editor" ]; then
        echo -e "\nOpening notes in ${GREEN}$editor${NC}..."
        sleep 0.5
        "$editor" "$temp_file"
    else
        echo -e "${YELLOW}No text editor found. Using basic input mode.${NC}"
        echo "Enter notes line by line. Press Enter on empty line to finish:"
        local new_notes=""
        local line
        while true; do
            read -rp "> " line
            if [ -z "$line" ]; then
                break
            fi
            new_notes="$new_notes$line\n"
        done
        echo -e "$new_notes" >| "$temp_file"
    fi
    
    # Read the edited notes
    local new_notes
    new_notes=$(cat "$temp_file")
    rm -f "$temp_file"
    
    # Update database
    local escaped_notes
    escaped_notes=$(sql_escape "$new_notes")
    
    if [ -z "$new_notes" ]; then
        # Delete notes if empty
        sqlite3 "$DB_FILE" "DELETE FROM repository_notes WHERE repo_id = $repo_id;"
        success "Notes cleared for $repo_name" wait
    else
        # Update or insert notes
        sqlite3 "$DB_FILE" "INSERT OR REPLACE INTO repository_notes (repo_id, notes) VALUES ($repo_id, '$escaped_notes');"
        success "Notes updated for $repo_name" wait
    fi
}

# Main menu
main_menu() {
    while true; do
        show_standard_layout "Main Menu"
        echo -e "${CYAN}Repository Management${NC}"
        echo -e "${GRAY}Help: G + 2${NC}"
        echo "1) Add a repository"
        echo "2) Edit a repository"
        echo "3) Remove a repository"
        echo "4) Search existing repositories"
        echo ""
        echo -e "${CYAN}Build Operations${NC}"
        echo -e "${GRAY}Help: G + 3${NC}"
        echo "5) Build an existing repository"
        echo "6) See build queue"
        echo "7) Build profiles"
        echo "8) Build history"
        echo ""
        echo -e "${CYAN}Repository Details${NC}"
        echo -e "${GRAY}Help: G + 4${NC}"
        echo "9) See/edit build details"
        echo "10) Launch a binary"
        echo "11) Dependencies"
        echo "12) Repository notes"
        echo ""
        echo -e "${CYAN}Import/Export${NC}"
        echo -e "${GRAY}Help: G + 5${NC}"
        echo "13) Save a gitbuildfile"
        echo "14) Save all gitbuildfiles"
        echo "15) Import gitbuildfile"
        echo ""
        echo -e "${CYAN}System${NC}"
        echo -e "${GRAY}Help: G + 6${NC}"
        echo "16) Refresh Git repository information"
        echo "17) Settings"
        if [ "$GITBUILDER_LAUNCHER_EXISTS" = false ]; then
            echo "18) Install GitBuilder desktop launcher"
        else
            echo "18) Remove GitBuilder desktop launcher"
        fi
        echo "19) Restart GitBuilder"
        
        # Read input with hotkey support
        echo ""
        local esc_status=0
        read_with_esc "Select option: " choice "HLG" || esc_status=$?
        
        # Handle hotkeys
        case $esc_status in
            27) # Esc - exit from main menu
                echo -e "\n${YELLOW}Exiting GitBuilder...${NC}"
                exit 0
                ;;
            72) # H - Help
                show_help_page
                continue
                ;;
            76) # L - Quick Launch
                quick_launch
                continue
                ;;
            71) # G - Goto help section
                goto_help_section
                continue
                ;;
        esac
        
        # Handle menu options
        case $choice in
            1) add_repo || continue ;;
            2)
                read -rp "Enter repository ID to edit: " id
                edit_repo "$id" || continue
                ;;
            3) 
                auto_backup "remove_repo"
                remove_repo || continue 
                ;;
            4)
                read -rp "Enter search term: " query
                search_repos "$query"
                read -rp "Press Enter to continue..."
                ;;
            5)
                read -rp "Enter repository ID to build: " id
                download_build "$id" || continue
                ;;
            6) build_queue_menu ;;
            7) build_profiles_menu ;;
            8) build_history_menu ;;
            9)
                read -rp "Enter repository ID to view details: " id
                # Validate that ID is provided and is a number
                if [[ -z "$id" ]] || ! [[ "$id" =~ ^[0-9]+$ ]]; then
                    error "Invalid repository ID: $id"
                    read -n 1 -s -r -p "Press any key to continue..."
                    continue
                fi
                show_build_details "$id" || continue
                ;;
            10)
                read -rp "Enter repository ID to launch: " id
                if launch_binary "$id"; then
                    echo -e "\nPress any key to continue..."
                    read -r -n 1
                fi
                ;;
            11) dependencies_menu ;;
            12) repository_notes_menu || continue ;;
            13)
                read -rp "Enter repository ID to save gitbuildfile: " id
                save_gitbuildfile "$id" || continue
                ;;
            14) save_all_gitbuildfiles || continue ;;
            15) import_gitbuildfile || continue ;;
            16) update_all_repos || continue ;;
            17) settings_menu ;;
            18) 
                if [ "$GITBUILDER_LAUNCHER_EXISTS" = false ]; then
                    install_gitbuilder_launcher
                else
                    remove_gitbuilder_launcher
                fi
                ;;
            19) # Restart GitBuilder
                echo -e "${CYAN}Restarting GitBuilder...${NC}"
                local script_path
                script_path="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"
                exec "$script_path" "$@"
                ;;
            *) 
                echo -e "${RED}Invalid option${NC}"
                sleep 1
                ;;
        esac
    done
}

# Get console width
get_console_width() {
    tput cols 2>/dev/null || echo 80
}

# Display repository table in top pane (compact format with short dates)
show_repository_table() {
    fetch_repo_data "short"
    render_table "Available Repositories:" "2|8|20|5|5|6|3"
}

# Read input with immediate Esc key detection and hotkey support
# Returns: 0 = normal input, 27 = Esc, 72 = H (help), 76 = L (launch), 71 = G (goto help)
# Usage: read_with_esc "prompt" variable [hotkeys]
#   hotkeys: string of enabled hotkeys, e.g., "HLG" for Help, Launch, and Goto
read_with_esc() {
	local prompt="$1"
	local _out_var="${2:-}"
	local hotkeys="${3:-HLG}"  # Default: H, L, and G enabled
	local input=""
	local char
	
	echo -n "$prompt"
	
	# Read character by character with -s to suppress auto-echo (we handle echo manually)
	while IFS= read -r -s -n1 char; do
		# Check for Esc key (ASCII 27)
		if [ "$char" = $'\e' ]; then
			echo ""
			return 27  # Return code for Esc
		fi
		
		# Check for hotkeys only when input is empty (first character)
		if [ -z "$input" ]; then
			# H for Help
			if [[ "$hotkeys" == *"H"* ]] && [[ "$char" == "H" || "$char" == "h" ]]; then
				echo ""
				return 72  # Return code for Help
			fi
			# L for Launch
			if [[ "$hotkeys" == *"L"* ]] && [[ "$char" == "L" || "$char" == "l" ]]; then
				echo ""
				return 76  # Return code for Launch
			fi
			# G for Goto help section
			if [[ "$hotkeys" == *"G"* ]] && [[ "$char" == "G" || "$char" == "g" ]]; then
				echo ""
				return 71  # Return code for Goto
			fi
		fi
		
		# Check for Enter key (read -n1 returns empty string for Enter)
		if [ -z "$char" ]; then
			echo ""  # Move to next line
			# Return the input
			if [ -n "$_out_var" ]; then
				printf -v "$_out_var" '%s' "$input"
			else
				# Legacy style: echo input so callers using command substitution still work
				echo "$input"
			fi
			return 0
		fi
		
		# Handle backspace/delete (ASCII 127 or backspace)
		if [ "$char" = $'\x7f' ] || [ "$char" = $'\b' ]; then
			if [ -n "$input" ]; then
				input="${input%?}"
				# Erase one character visually
				echo -ne "\b \b"
			fi
		else
			# Echo the character and add to input
			echo -n "$char"
			input+="$char"
		fi
	done
	
	# If we get here, EOF was reached - treat as Esc
	echo ""
	return 27
}

# Display common key shortcuts
show_common_keys() {
    echo ""
    echo -e "${GRAY}Esc = Back/Exit | H = Help | G = Goto Help # | L = Quick Launch${NC}"
}

# Quick launch - prompt user to select and launch a binary
quick_launch() {
    echo -e "\n${BLUE}Quick Launch${NC}"
    
    # Get list of repositories with binaries
    local repos_with_binaries
    repos_with_binaries=$(sqlite3 "$DB_FILE" "SELECT id, name, binary_path FROM repositories WHERE deleted = 0 AND binary_path IS NOT NULL AND binary_path != '' ORDER BY name;")
    
    if [ -z "$repos_with_binaries" ]; then
        echo -e "${YELLOW}No repositories have registered binaries.${NC}"
        echo -e "Use 'Launch binary' (option 10) to register a binary first."
        read -rp "Press Enter to continue..."
        return 1
    fi
    
    echo -e "\n${CYAN}Select a binary to launch:${NC}"
    local -a repo_ids=()
    local -a repo_names=()
    local -a binary_paths=()
    local count=1
    
    while IFS='|' read -r id name binary_path; do
        local binary_name
        binary_name=$(basename "$binary_path")
        echo "$count) $name ($binary_name)"
        repo_ids+=("$id")
        repo_names+=("$name")
        binary_paths+=("$binary_path")
        ((count++))
    done <<< "$repos_with_binaries"
    
    echo ""
    read -rp "Select (1-$((count-1)), or Enter to cancel): " selection
    
    if [ -z "$selection" ]; then
        return 0
    fi
    
    if [[ "$selection" =~ ^[0-9]+$ ]] && [ "$selection" -ge 1 ] && [ "$selection" -lt "$count" ]; then
        local idx=$((selection - 1))
        local selected_id="${repo_ids[$idx]}"
        local selected_name="${repo_names[$idx]}"
        local selected_binary="${binary_paths[$idx]}"
        
        if [ -x "$selected_binary" ]; then
            echo -e "\n${GREEN}Launching $selected_name...${NC}"
            echo "1) Quiet (background)"
            echo "2) Verbose (show output)"
            read -rp "Launch mode (1/2): " mode
            
            if [ "$mode" = "1" ]; then
                nohup "$selected_binary" >/dev/null 2>&1 &
                echo -e "${GREEN}Launched in background (PID: $!)${NC}"
            else
                echo -e "${BLUE}Running $selected_binary...${NC}"
                "$selected_binary"
            fi
            read -rp "Press Enter to continue..."
        else
            echo -e "${RED}Binary not found or not executable: $selected_binary${NC}"
            read -rp "Press Enter to continue..."
            return 1
        fi
    else
        echo -e "${RED}Invalid selection${NC}"
        return 1
    fi
}

# Show help page (reads from HELP file)
show_help_page() {
    clear
    if [ -f "$HELP_FILE" ]; then
        # Use less for scrollable help, or cat if less unavailable
        if command -v less &>/dev/null; then
            less -R "$HELP_FILE"
        else
            cat "$HELP_FILE"
            echo ""
            echo -e "${GRAY}Press any key to return...${NC}"
            read -r -n 1
        fi
    else
        # Fallback if HELP file doesn't exist
        echo -e "${YELLOW}╔══════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${YELLOW}║${NC}              ${CYAN}GitBuilder v${VERSION} - Help${NC}                        ${YELLOW}║${NC}"
        echo -e "${YELLOW}╚══════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "${RED}HELP file not found at: $HELP_FILE${NC}"
        echo ""
        echo -e "${BLUE}Keyboard Shortcuts${NC}"
        echo "  Esc     - Return to previous screen / Exit from main menu"
        echo "  H       - Show this help page (from any menu)"
        echo "  L       - Quick launch a binary (main menu & build details)"
        echo "  G       - Go to specific help section"
        echo "  0-9     - Select menu options"
        echo ""
        echo -e "${CYAN}GitHub: $GITHUB_REPO${NC}"
        echo ""
        echo -e "${GRAY}Press any key to return...${NC}"
        read -r -n 1
    fi
}

# Show specific help section by number
show_help_section() {
    local section_num="$1"
    
    if [ ! -f "$HELP_FILE" ]; then
        echo -e "${RED}HELP file not found${NC}"
        read -rp "Press Enter to continue..."
        return 1
    fi
    
    # Extract the section content between [N] markers
    # Find the line with [N] UPPERCASE TITLE (section header), skip the === line, print until next section
    local section_content
    section_content=$(awk -v num="$section_num" '
        BEGIN { found=0 }
        $0 ~ "^\\[" num "\\] [A-Z]" { found=1; print; next }
        found && /^=+$/ && !started { started=1; next }
        found && started && /^\[[0-9]+\] [A-Z]/ { exit }
        found && started { print }
    ' "$HELP_FILE")
    
    if [ -z "$section_content" ]; then
        echo -e "${RED}Help section [$section_num] not found${NC}"
        echo "Available sections: 1-12"
        read -rp "Press Enter to continue..."
        return 1
    fi
    
    clear
    echo -e "${YELLOW}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${YELLOW}║${NC}              ${CYAN}GitBuilder Help - Section [$section_num]${NC}                  ${YELLOW}║${NC}"
    echo -e "${YELLOW}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo "$section_content"
    echo ""
    echo -e "${GRAY}Press any key to return...${NC}"
    read -r -n 1
}

# Prompt for help section number and display it
goto_help_section() {
    echo ""
    echo -e "${CYAN}Help Sections:${NC}"
    echo "  [1]  Main Menu Overview"
    echo "  [2]  Repository Management"
    echo "  [3]  Build Operations"
    echo "  [4]  Repository Details"
    echo "  [5]  Import/Export (gitbuildfile)"
    echo "  [6]  System Settings"
    echo "  [7]  File Browser"
    echo "  [8]  Build System Support"
    echo "  [9]  Build Optimization"
    echo "  [10] Desktop Launchers"
    echo "  [11] Data Storage & Backup"
    echo "  [12] Troubleshooting"
    echo ""
    read -rp "Enter section number (1-12): " section_num
    
    if [[ "$section_num" =~ ^[0-9]+$ ]] && [ "$section_num" -ge 1 ] && [ "$section_num" -le 12 ]; then
        show_help_section "$section_num"
    else
        echo -e "${RED}Invalid section number${NC}"
        sleep 1
    fi
}

# Standard layout for all screens
# Arguments:
#   $1 - screen_name (optional): Title to display
#   $2 - show_table (optional): "true" (default) or "false" to hide repository table
show_standard_layout() {
    local screen_name="${1:-}"
    local show_table="${2:-true}"
    clear
    echo -e "${YELLOW}GitBuilder v${VERSION}${NC}${screen_name:+ - ${CYAN}${screen_name}${NC}}"
    show_common_keys
    echo ""
    if [ "$show_table" = "true" ]; then
        show_repository_table
        echo ""
    fi
}

# Repository update check (real loading screen)
update_repository_info() {
    echo -e "\n${YELLOW}GitHub Package Manager${NC}"
    echo -e "\n${CYAN}Loading application...${NC}"
    
    # Simulate loading with progress
    echo -n "Initializing components"
    for i in {1..3}; do
        echo -n "."
        sleep 0.3
    done
    echo ""
    
    echo -e "\n${BLUE}Updating repository information...${NC}"
    while IFS='|' read -r id name url last_commit; do
        # If last_commit is empty or older than 1 day, update it
        if [ -z "$last_commit" ] || [ "$(date -d "$last_commit" +%s 2>/dev/null || echo 0)" -lt "$(date -d "1 day ago" +%s)" ]; then
            update_commit_date "$id" "$url"
        fi
    done < <(sqlite3 "$DB_FILE" "SELECT id, name, url, last_commit FROM repositories WHERE deleted = 0;")
    
    echo -e "\n${YELLOW}Launching main menu...${NC}"
    sleep 0.3
    clear
}

# =============================================================================
# BACKUP AND RESTORE FUNCTIONS
# =============================================================================

# Create database backup
backup_database() {
    local backup_file="${1:-}"
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S)
    
    if [ -z "$backup_file" ]; then
        backup_file="$BACKUP_DIR/gitbuilder_backup_$timestamp.sql"
    fi
    
    # Ensure backup directory exists
    mkdir -p "$(dirname "$backup_file")"
    
    echo -e "${BLUE}Creating database backup...${NC}"
    
    if sqlite3 "$DB_FILE" ".dump" > "$backup_file" 2>/dev/null; then
        # Also backup config file
        if [ -f "$CONFIG_FILE" ]; then
            cp "$CONFIG_FILE" "${backup_file%.sql}.config"
        fi
        
        # Compress if file is large
        local size
        size=$(stat -c%s "$backup_file" 2>/dev/null || echo 0)
        if [ "$size" -gt 1048576 ]; then  # > 1MB
            gzip "$backup_file"
            backup_file="${backup_file}.gz"
        fi
        
        chmod 600 "$backup_file"
        success "Backup saved to: $backup_file" wait
        return 0
    else
        error "Failed to create backup"
        return 1
    fi
}

# Restore database from backup
restore_database() {
    local backup_file="${1:-}"
    
    if [ -z "$backup_file" ]; then
        # List available backups
        echo -e "${BLUE}Available backups:${NC}"
        local backups=()
        while IFS= read -r -d '' file; do
            backups+=("$file")
        done < <(find "$BACKUP_DIR" -name "*.sql*" -print0 2>/dev/null | sort -z -r)
        
        if [ ${#backups[@]} -eq 0 ]; then
            echo -e "${YELLOW}No backups found in $BACKUP_DIR${NC}"
            return 1
        fi
        
        local i=1
        for backup in "${backups[@]}"; do
            local size
            size=$(du -h "$backup" 2>/dev/null | cut -f1)
            local date
            date=$(stat -c%y "$backup" 2>/dev/null | cut -d' ' -f1)
            echo "$i) $(basename "$backup") ($size, $date)"
            ((i++))
        done
        
        read -rp "Select backup to restore (1-${#backups[@]}): " choice
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "${#backups[@]}" ]; then
            backup_file="${backups[$((choice-1))]}"
        else
            error "Invalid selection"
            return 1
        fi
    fi
    
    if [ ! -f "$backup_file" ]; then
        error "Backup file not found: $backup_file"
        return 1
    fi
    
    echo -e "${YELLOW}WARNING: This will replace your current database!${NC}"
    read -rp "Are you sure you want to restore from $(basename "$backup_file")? (y/N): " confirm
    
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}Restore cancelled${NC}"
        return 1
    fi
    
    # Create backup of current database first
    echo -e "${BLUE}Backing up current database...${NC}"
    backup_database "$BACKUP_DIR/pre_restore_$(date +%Y%m%d_%H%M%S).sql"
    
    # Handle compressed backups
    local restore_file="$backup_file"
    if [[ "$backup_file" == *.gz ]]; then
        restore_file=$(mktemp)
        gunzip -c "$backup_file" > "$restore_file"
    fi
    
    # Restore database
    echo -e "${BLUE}Restoring database...${NC}"
    rm -f "$DB_FILE"
    if sqlite3 "$DB_FILE" < "$restore_file"; then
        # Restore config if available
        local config_backup="${backup_file%.sql*}.config"
        if [ -f "$config_backup" ]; then
            cp "$config_backup" "$CONFIG_FILE"
            load_config
        fi
        
        [ "$restore_file" != "$backup_file" ] && rm -f "$restore_file"
        success "Database restored successfully" wait
        return 0
    else
        [ "$restore_file" != "$backup_file" ] && rm -f "$restore_file"
        error "Failed to restore database"
        return 1
    fi
}

# Auto-backup before destructive operations
auto_backup() {
    local reason="${1:-auto}"
    local backup_file="$BACKUP_DIR/auto_${reason}_$(date +%Y%m%d_%H%M%S).sql"
    sqlite3 "$DB_FILE" ".dump" > "$backup_file" 2>/dev/null
    chmod 600 "$backup_file"
    
    # Keep only last 10 auto-backups
    find "$BACKUP_DIR" -name "auto_*.sql" -type f | sort -r | tail -n +11 | xargs -r rm -f
}

# =============================================================================
# BINARY BACKUP FUNCTIONS
# =============================================================================

# Count binary backups for a repository
count_binary_backups() {
    local repo_id="$1"
    sqlite3 "$DB_FILE" "SELECT COUNT(*) FROM binary_backups WHERE repo_id = $repo_id;"
}

# Get binary backups for a repository
get_binary_backups() {
    local repo_id="$1"
    sqlite3 "$DB_FILE" "SELECT id, backup_path, version_label, created_at FROM binary_backups WHERE repo_id = $repo_id ORDER BY created_at DESC;"
}

# Create a backup of the current binary before rebuild
backup_binary() {
    local repo_id="$1"
    local version_label="${2:-}"
    
    # Get current binary path
    local binary_path
    binary_path=$(sqlite3 "$DB_FILE" "SELECT binary_path FROM repositories WHERE id = $repo_id;")
    
    if [ -z "$binary_path" ] || [ ! -f "$binary_path" ]; then
        return 1  # No binary to backup
    fi
    
    # Get repository name
    local repo_name
    repo_name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $repo_id;")
    
    # Check backup count and warn if at limit
    local backup_count
    backup_count=$(count_binary_backups "$repo_id")
    
    if [ "$backup_count" -ge "$BINARY_BACKUP_LIMIT" ]; then
        echo -e "${YELLOW}Warning: You have $backup_count backups (limit: $BINARY_BACKUP_LIMIT).${NC}"
        echo -e "${YELLOW}The oldest backup will be deleted if you continue.${NC}"
        read -rp "Continue with backup? (Y/n): " confirm
        if [[ "$confirm" =~ ^[Nn]$ ]]; then
            return 1
        fi
        
        # Delete oldest backup
        local oldest_id oldest_path
        oldest_id=$(sqlite3 "$DB_FILE" "SELECT id FROM binary_backups WHERE repo_id = $repo_id ORDER BY created_at ASC LIMIT 1;")
        oldest_path=$(sqlite3 "$DB_FILE" "SELECT backup_path FROM binary_backups WHERE id = $oldest_id;")
        
        if [ -n "$oldest_path" ] && [ -f "$oldest_path" ]; then
            rm -f "$oldest_path"
        fi
        sqlite3 "$DB_FILE" "DELETE FROM binary_backups WHERE id = $oldest_id;"
        echo -e "${CYAN}Deleted oldest backup${NC}"
    fi
    
    # Create backup directory for this repo
    local repo_backup_dir="$BINARY_BACKUPS_DIR/$repo_name"
    mkdir -p "$repo_backup_dir"
    
    # Generate backup filename with timestamp
    local binary_name
    binary_name=$(basename "$binary_path")
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_path="$repo_backup_dir/${binary_name}_${timestamp}"
    
    # Copy binary to backup location
    if cp "$binary_path" "$backup_path"; then
        chmod +x "$backup_path"
        
        # Generate version label if not provided
        if [ -z "$version_label" ]; then
            version_label="Backup $(date '+%Y-%m-%d %H:%M')"
        fi
        
        # Record in database
        local escaped_backup_path escaped_original_path escaped_label
        escaped_backup_path=$(sql_escape "$backup_path")
        escaped_original_path=$(sql_escape "$binary_path")
        escaped_label=$(sql_escape "$version_label")
        
        sqlite3 "$DB_FILE" "INSERT INTO binary_backups (repo_id, backup_path, original_path, version_label) VALUES ($repo_id, '$escaped_backup_path', '$escaped_original_path', '$escaped_label');"
        
        echo -e "${GREEN}Binary backed up: $backup_path${NC}"
        return 0
    else
        echo -e "${RED}Failed to backup binary${NC}"
        return 1
    fi
}

# List binary backups for a repository
list_binary_backups() {
    local repo_id="$1"
    
    local repo_name
    repo_name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $repo_id;")
    
    echo -e "\n${BLUE}Binary Backups for $repo_name:${NC}"
    
    local backups
    backups=$(get_binary_backups "$repo_id")
    
    if [ -z "$backups" ]; then
        echo -e "${YELLOW}No backups found${NC}"
        return 1
    fi
    
    local count=1
    while IFS='|' read -r id backup_path version_label created_at; do
        local exists_status="${GREEN}✓${NC}"
        [ ! -f "$backup_path" ] && exists_status="${RED}✗${NC}"
        
        echo -e "$count) [$exists_status] $version_label"
        echo -e "   Created: $created_at"
        echo -e "   Path: $backup_path"
        ((count++))
    done <<< "$backups"
}

# Launch a backup binary
launch_backup_binary() {
    local repo_id="$1"
    
    local backups
    backups=$(get_binary_backups "$repo_id")
    
    if [ -z "$backups" ]; then
        echo -e "${YELLOW}No backups found for this repository${NC}"
        return 1
    fi
    
    echo -e "\n${BLUE}Select a backup to launch:${NC}"
    local -a backup_ids=()
    local -a backup_paths=()
    local count=1
    
    while IFS='|' read -r id backup_path version_label created_at; do
        if [ -f "$backup_path" ]; then
            echo "$count) $version_label ($created_at)"
            backup_ids+=("$id")
            backup_paths+=("$backup_path")
            ((count++))
        fi
    done <<< "$backups"
    
    if [ ${#backup_paths[@]} -eq 0 ]; then
        echo -e "${YELLOW}No valid backup binaries found${NC}"
        return 1
    fi
    
    echo ""
    read -rp "Select backup (1-$((count-1))): " selection
    
    if [[ "$selection" =~ ^[0-9]+$ ]] && [ "$selection" -ge 1 ] && [ "$selection" -lt "$count" ]; then
        local idx=$((selection - 1))
        local selected_binary="${backup_paths[$idx]}"
        
        echo "1) Quiet (background)"
        echo "2) Verbose (show output)"
        read -rp "Launch mode (1/2): " mode
        
        if [ "$mode" = "1" ]; then
            nohup "$selected_binary" >/dev/null 2>&1 &
            echo -e "${GREEN}Launched in background (PID: $!)${NC}"
        else
            echo -e "${BLUE}Running $selected_binary...${NC}"
            "$selected_binary"
        fi
    else
        echo -e "${RED}Invalid selection${NC}"
        return 1
    fi
}

# Restore a backup binary (replace current with backup)
restore_backup_binary() {
    local repo_id="$1"
    
    local backups
    backups=$(get_binary_backups "$repo_id")
    
    if [ -z "$backups" ]; then
        echo -e "${YELLOW}No backups found for this repository${NC}"
        return 1
    fi
    
    echo -e "\n${BLUE}Select a backup to restore:${NC}"
    local -a backup_ids=()
    local -a backup_paths=()
    local -a original_paths=()
    local count=1
    
    while IFS='|' read -r id backup_path version_label created_at; do
        if [ -f "$backup_path" ]; then
            echo "$count) $version_label ($created_at)"
            backup_ids+=("$id")
            backup_paths+=("$backup_path")
            # Get original path
            local orig_path
            orig_path=$(sqlite3 "$DB_FILE" "SELECT original_path FROM binary_backups WHERE id = $id;")
            original_paths+=("$orig_path")
            ((count++))
        fi
    done <<< "$backups"
    
    if [ ${#backup_paths[@]} -eq 0 ]; then
        echo -e "${YELLOW}No valid backup binaries found${NC}"
        return 1
    fi
    
    echo ""
    read -rp "Select backup to restore (1-$((count-1))): " selection
    
    if [[ "$selection" =~ ^[0-9]+$ ]] && [ "$selection" -ge 1 ] && [ "$selection" -lt "$count" ]; then
        local idx=$((selection - 1))
        local selected_backup="${backup_paths[$idx]}"
        local original_path="${original_paths[$idx]}"
        
        echo -e "${YELLOW}This will replace: $original_path${NC}"
        read -rp "Are you sure? (y/N): " confirm
        
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            if cp "$selected_backup" "$original_path"; then
                chmod +x "$original_path"
                echo -e "${GREEN}Binary restored successfully${NC}"
                return 0
            else
                echo -e "${RED}Failed to restore binary${NC}"
                return 1
            fi
        fi
    else
        echo -e "${RED}Invalid selection${NC}"
        return 1
    fi
}

# Delete a binary backup
delete_binary_backup() {
    local repo_id="$1"
    
    local backups
    backups=$(get_binary_backups "$repo_id")
    
    if [ -z "$backups" ]; then
        echo -e "${YELLOW}No backups found for this repository${NC}"
        return 1
    fi
    
    echo -e "\n${BLUE}Select a backup to delete:${NC}"
    local -a backup_ids=()
    local -a backup_paths=()
    local count=1
    
    while IFS='|' read -r id backup_path version_label created_at; do
        echo "$count) $version_label ($created_at)"
        backup_ids+=("$id")
        backup_paths+=("$backup_path")
        ((count++))
    done <<< "$backups"
    
    echo ""
    read -rp "Select backup to delete (1-$((count-1))): " selection
    
    if [[ "$selection" =~ ^[0-9]+$ ]] && [ "$selection" -ge 1 ] && [ "$selection" -lt "$count" ]; then
        local idx=$((selection - 1))
        local selected_id="${backup_ids[$idx]}"
        local selected_path="${backup_paths[$idx]}"
        
        read -rp "Are you sure you want to delete this backup? (y/N): " confirm
        
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            # Delete file
            [ -f "$selected_path" ] && rm -f "$selected_path"
            
            # Delete from database
            sqlite3 "$DB_FILE" "DELETE FROM binary_backups WHERE id = $selected_id;"
            
            echo -e "${GREEN}Backup deleted${NC}"
            return 0
        fi
    else
        echo -e "${RED}Invalid selection${NC}"
        return 1
    fi
}

# Binary backups menu
binary_backups_menu() {
    local repo_id="$1"
    
    if [ -z "$repo_id" ]; then
        read -rp "Enter repository ID: " repo_id
    fi
    
    if ! is_valid_id "$repo_id"; then
        error "Invalid repository ID"
        return 1
    fi
    
    local repo_name
    repo_name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $repo_id AND deleted = 0;")
    
    if [ -z "$repo_name" ]; then
        error "Repository not found"
        return 1
    fi
    
    while true; do
        show_standard_layout "Binary Backups - $repo_name" false
        
        local backup_count
        backup_count=$(count_binary_backups "$repo_id")
        echo -e "Backups: ${GREEN}$backup_count${NC} / ${YELLOW}$BINARY_BACKUP_LIMIT${NC} (limit)"
        echo ""
        echo "1) List backups"
        echo "2) Create backup now"
        echo "3) Launch backup binary"
        echo "4) Restore backup (replace current)"
        echo "5) Delete backup"
        
        echo ""
        local esc_status=0
        read_with_esc "Select option: " choice "HG" || esc_status=$?
        
        # Handle hotkeys
        case $esc_status in
            27) return 0 ;;  # Esc
            72) show_help_page; continue ;;  # H - Help
            71) goto_help_section; continue ;;  # G - Goto help section
        esac
        
        case $choice in
            1) list_binary_backups "$repo_id"; read -rp "Press Enter to continue..." ;;
            2) 
                read -rp "Enter version label (or Enter for auto): " label
                backup_binary "$repo_id" "$label"
                read -rp "Press Enter to continue..."
                ;;
            3) launch_backup_binary "$repo_id" ;;
            4) restore_backup_binary "$repo_id" ;;
            5) delete_binary_backup "$repo_id" ;;
            *) echo -e "${RED}Invalid option${NC}"; sleep 1 ;;
        esac
    done
}

# =============================================================================
# DESKTOP LAUNCHER FUNCTIONS
# =============================================================================

# Available menu categories for .desktop files
DESKTOP_CATEGORIES=("Development" "Game" "Graphics" "Network" "Office" "Science" "System" "Utility" "AudioVideo" "Education")

# Check and update GitBuilder's own desktop launcher
check_gitbuilder_launcher() {
    local script_path
    script_path=$(realpath "${BASH_SOURCE[0]}")
    
    # Expected launcher content
    local expected_name="GitBuilder"
    local expected_comment="GitHub Repository Manager and Build Automation Tool"
    local expected_exec="$script_path"
    local expected_icon="utilities-terminal"
    local expected_category="Development"
    
    if [ -f "$GITBUILDER_DESKTOP_FILE" ]; then
        GITBUILDER_LAUNCHER_EXISTS=true
        
        # Read current values from the desktop file
        local current_name current_comment current_exec current_icon
        current_name=$(grep "^Name=" "$GITBUILDER_DESKTOP_FILE" 2>/dev/null | cut -d'=' -f2-)
        current_comment=$(grep "^Comment=" "$GITBUILDER_DESKTOP_FILE" 2>/dev/null | cut -d'=' -f2-)
        current_exec=$(grep "^Exec=" "$GITBUILDER_DESKTOP_FILE" 2>/dev/null | cut -d'=' -f2-)
        current_icon=$(grep "^Icon=" "$GITBUILDER_DESKTOP_FILE" 2>/dev/null | cut -d'=' -f2-)
        
        # Check if any values need updating
        local needs_update=false
        if [ "$current_name" != "$expected_name" ] || \
           [ "$current_comment" != "$expected_comment" ] || \
           [ "$current_exec" != "$expected_exec" ] || \
           [ "$current_icon" != "$expected_icon" ]; then
            needs_update=true
        fi
        
        # Update if necessary (silently)
        if [ "$needs_update" = true ]; then
            create_gitbuilder_launcher_file "$script_path" "$expected_name" "$expected_comment" "$expected_icon" "$expected_category"
        fi
    else
        GITBUILDER_LAUNCHER_EXISTS=false
    fi
}

# Create GitBuilder's desktop launcher file
create_gitbuilder_launcher_file() {
    local exec_path="$1"
    local name="$2"
    local comment="$3"
    local icon="$4"
    local category="$5"
    
    # Ensure applications directory exists
    mkdir -p "$DESKTOP_LAUNCHERS_DIR"
    
    cat > "$GITBUILDER_DESKTOP_FILE" << EOF
[Desktop Entry]
Version=1.0
Type=Application
Name=$name
Comment=$comment
Exec=$exec_path
Icon=$icon
Terminal=true
Categories=$category;
StartupNotify=false
EOF
    
    chmod +x "$GITBUILDER_DESKTOP_FILE"
}

# Install GitBuilder's desktop launcher (interactive)
install_gitbuilder_launcher() {
    local script_path
    script_path=$(realpath "${BASH_SOURCE[0]}")
    
    echo -e "\n${BLUE}Install GitBuilder Desktop Launcher${NC}"
    echo "============================================"
    echo ""
    echo "This will create a desktop launcher for GitBuilder"
    echo "so you can launch it from your application menu."
    echo ""
    echo -e "Location: ${CYAN}$GITBUILDER_DESKTOP_FILE${NC}"
    echo -e "Binary:   ${CYAN}$script_path${NC}"
    echo ""
    
    read -rp "Install desktop launcher? (Y/n): " confirm
    if [[ "$confirm" =~ ^[Nn]$ ]]; then
        echo -e "${YELLOW}Installation cancelled${NC}"
        read -rp "Press Enter to continue..."
        return 0
    fi
    
    create_gitbuilder_launcher_file "$script_path" "GitBuilder" "GitHub Repository Manager and Build Automation Tool" "utilities-terminal" "Development"
    
    if [ -f "$GITBUILDER_DESKTOP_FILE" ]; then
        GITBUILDER_LAUNCHER_EXISTS=true
        echo -e "\n${GREEN}Desktop launcher installed successfully!${NC}"
        echo -e "${CYAN}GitBuilder should now appear in your application menu under 'Development'.${NC}"
        echo -e "${YELLOW}Note: You may need to log out and back in for it to appear.${NC}"
    else
        echo -e "\n${RED}Failed to create desktop launcher${NC}"
    fi
    
    read -rp "Press Enter to continue..."
}

# Remove GitBuilder's desktop launcher (interactive)
remove_gitbuilder_launcher() {
    echo -e "\n${BLUE}Remove GitBuilder Desktop Launcher${NC}"
    echo "============================================"
    echo ""
    echo -e "This will remove the desktop launcher for GitBuilder."
    echo -e "Location: ${CYAN}$GITBUILDER_DESKTOP_FILE${NC}"
    echo ""
    
    read -rp "Remove desktop launcher? (y/N): " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}Removal cancelled${NC}"
        read -rp "Press Enter to continue..."
        return 0
    fi
    
    if rm -f "$GITBUILDER_DESKTOP_FILE" 2>/dev/null; then
        GITBUILDER_LAUNCHER_EXISTS=false
        echo -e "\n${GREEN}Desktop launcher removed successfully!${NC}"
        echo -e "${YELLOW}Note: You may need to log out and back in for the change to take effect.${NC}"
    else
        echo -e "\n${RED}Failed to remove desktop launcher${NC}"
    fi
    
    read -rp "Press Enter to continue..."
}

# Create a desktop launcher for a repository binary
create_desktop_launcher() {
    local repo_id="$1"
    
    if ! is_valid_id "$repo_id"; then
        error "Invalid repository ID"
        return 1
    fi
    
    # Get repository info
    local repo_info
    repo_info=$(sqlite3 "$DB_FILE" "SELECT name, binary_path FROM repositories WHERE id = $repo_id AND deleted = 0;")
    
    if [ -z "$repo_info" ]; then
        error "Repository not found"
        return 1
    fi
    
    local repo_name binary_path
    repo_name=$(echo "$repo_info" | cut -d'|' -f1)
    binary_path=$(echo "$repo_info" | cut -d'|' -f2)
    
    if [ -z "$binary_path" ] || [ ! -x "$binary_path" ]; then
        echo -e "${RED}No executable binary registered for this repository.${NC}"
        echo -e "Please register a binary first (option 10 in build details)."
        read -rp "Press Enter to continue..."
        return 1
    fi
    
    echo -e "\n${BLUE}Create Desktop Launcher for $repo_name${NC}"
    
    # Get launcher name
    local launcher_name
    read -rp "Launcher name [$repo_name]: " launcher_name
    [ -z "$launcher_name" ] && launcher_name="$repo_name"
    
    # Get description
    local description
    read -rp "Description: " description
    [ -z "$description" ] && description="$repo_name - Built with GitBuilder"
    
    # Select menu category
    echo -e "\n${CYAN}Select menu category:${NC}"
    local i=1
    for cat in "${DESKTOP_CATEGORIES[@]}"; do
        echo "$i) $cat"
        ((i++))
    done
    
    local cat_choice
    read -rp "Select category (1-${#DESKTOP_CATEGORIES[@]}) [1]: " cat_choice
    [ -z "$cat_choice" ] && cat_choice=1
    
    local category="${DESKTOP_CATEGORIES[0]}"
    if [[ "$cat_choice" =~ ^[0-9]+$ ]] && [ "$cat_choice" -ge 1 ] && [ "$cat_choice" -le "${#DESKTOP_CATEGORIES[@]}" ]; then
        category="${DESKTOP_CATEGORIES[$((cat_choice-1))]}"
    fi
    
    # Select icon
    local icon_path=""
    echo -e "\n${CYAN}Select icon:${NC}"
    echo "1) Browse for icon file"
    echo "2) Use system icon name"
    echo "3) No icon"
    
    local icon_choice
    read -rp "Select option [1]: " icon_choice
    [ -z "$icon_choice" ] && icon_choice=1
    
    case "$icon_choice" in
        1)
            # Browse for icon
            echo -e "\n${BLUE}Browse for icon file...${NC}"
            local src_dir="$SRC_DIR/$repo_name"
            [ ! -d "$src_dir" ] && src_dir="$HOME"
            
            file_browser "$src_dir" "image" || true
            if [ -f "/tmp/gitbuilder_selected_file" ]; then
                icon_path=$(cat "/tmp/gitbuilder_selected_file")
                rm -f "/tmp/gitbuilder_selected_file"
            fi
            ;;
        2)
            # System icon name
            read -rp "Enter system icon name (e.g., 'utilities-terminal'): " icon_path
            ;;
        3|*)
            # No icon
            icon_path=""
            ;;
    esac
    
    # Generate desktop file
    local desktop_filename
    desktop_filename=$(echo "$launcher_name" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
    local desktop_file="$DESKTOP_LAUNCHERS_DIR/gitbuilder-${desktop_filename}.desktop"
    
    # Check if launcher already exists
    if [ -f "$desktop_file" ]; then
        echo -e "${YELLOW}Launcher already exists: $desktop_file${NC}"
        read -rp "Overwrite? (y/N): " overwrite
        if [[ ! "$overwrite" =~ ^[Yy]$ ]]; then
            echo -e "${YELLOW}Cancelled${NC}"
            return 0
        fi
    fi
    
    # Create .desktop file
    cat > "$desktop_file" << EOF
[Desktop Entry]
Version=1.0
Type=Application
Name=$launcher_name
Comment=$description
Exec=$binary_path
Icon=$icon_path
Terminal=false
Categories=$category;
StartupNotify=true
EOF
    
    chmod +x "$desktop_file"
    
    # Record in database
    local escaped_desktop_path escaped_icon_path escaped_category
    escaped_desktop_path=$(sql_escape "$desktop_file")
    escaped_icon_path=$(sql_escape "$icon_path")
    escaped_category=$(sql_escape "$category")
    
    # Check if entry exists
    local existing
    existing=$(sqlite3 "$DB_FILE" "SELECT id FROM desktop_launchers WHERE repo_id = $repo_id;")
    
    if [ -n "$existing" ]; then
        sqlite3 "$DB_FILE" "UPDATE desktop_launchers SET desktop_file_path = '$escaped_desktop_path', icon_path = '$escaped_icon_path', menu_category = '$escaped_category' WHERE repo_id = $repo_id;"
    else
        sqlite3 "$DB_FILE" "INSERT INTO desktop_launchers (repo_id, desktop_file_path, icon_path, menu_category) VALUES ($repo_id, '$escaped_desktop_path', '$escaped_icon_path', '$escaped_category');"
    fi
    
    echo -e "\n${GREEN}Desktop launcher created: $desktop_file${NC}"
    echo -e "${CYAN}The launcher should appear in your application menu under '$category'.${NC}"
    echo -e "${YELLOW}Note: You may need to log out and back in for the launcher to appear.${NC}"
    
    read -rp "Press Enter to continue..."
}

# Update desktop launcher if binary path has changed
# Returns 0 if updated, 1 if no update needed, 2 if no launcher exists
update_desktop_launcher_if_needed() {
    local repo_id="$1"
    
    # Get current launcher info
    local launcher_path
    launcher_path=$(sqlite3 "$DB_FILE" "SELECT desktop_file_path FROM desktop_launchers WHERE repo_id = $repo_id;" 2>/dev/null)
    
    if [ -z "$launcher_path" ] || [ ! -f "$launcher_path" ]; then
        return 2  # No launcher exists
    fi
    
    # Get current binary path from repository
    local current_binary
    current_binary=$(sqlite3 "$DB_FILE" "SELECT binary_path FROM repositories WHERE id = $repo_id;" 2>/dev/null)
    
    if [ -z "$current_binary" ]; then
        return 1  # No binary registered
    fi
    
    # Get binary path from launcher file
    local launcher_binary
    launcher_binary=$(grep "^Exec=" "$launcher_path" 2>/dev/null | cut -d'=' -f2-)
    
    # Compare and update if different
    if [ "$current_binary" != "$launcher_binary" ]; then
        # Update the Exec line in the launcher
        sed -i "s|^Exec=.*|Exec=$current_binary|" "$launcher_path"
        echo -e "${CYAN}Desktop launcher updated with new binary path${NC}"
        return 0
    fi
    
    return 1  # No update needed
}

# Check if a repository has a desktop launcher
# Returns 0 (true) if launcher exists, 1 (false) otherwise
repo_has_desktop_launcher() {
    local repo_id="$1"
    local launcher_path
    launcher_path=$(sqlite3 "$DB_FILE" "SELECT desktop_file_path FROM desktop_launchers WHERE repo_id = $repo_id;" 2>/dev/null)
    
    # Check both database record and file existence
    if [ -n "$launcher_path" ] && [ -f "$launcher_path" ]; then
        return 0
    fi
    return 1
}

# Delete a desktop launcher (non-interactive, for internal use)
delete_desktop_launcher_silent() {
    local repo_id="$1"
    
    local launcher_info
    launcher_info=$(sqlite3 "$DB_FILE" "SELECT desktop_file_path FROM desktop_launchers WHERE repo_id = $repo_id;")
    
    if [ -z "$launcher_info" ]; then
        return 1
    fi
    
    [ -f "$launcher_info" ] && rm -f "$launcher_info"
    sqlite3 "$DB_FILE" "DELETE FROM desktop_launchers WHERE repo_id = $repo_id;"
    return 0
}

# Delete a desktop launcher (interactive)
delete_desktop_launcher() {
    local repo_id="$1"
    
    local launcher_info repo_name
    launcher_info=$(sqlite3 "$DB_FILE" "SELECT desktop_file_path FROM desktop_launchers WHERE repo_id = $repo_id;")
    repo_name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $repo_id;")
    
    if [ -z "$launcher_info" ]; then
        echo -e "${YELLOW}No desktop launcher found for this repository${NC}"
        read -rp "Press Enter to continue..."
        return 1
    fi
    
    echo -e "\n${BLUE}Remove Desktop Launcher${NC}"
    echo "============================================"
    echo -e "Repository: ${CYAN}$repo_name${NC}"
    echo -e "Launcher:   ${CYAN}$launcher_info${NC}"
    echo ""
    
    read -rp "Remove this desktop launcher? (y/N): " confirm
    
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        [ -f "$launcher_info" ] && rm -f "$launcher_info"
        sqlite3 "$DB_FILE" "DELETE FROM desktop_launchers WHERE repo_id = $repo_id;"
        echo -e "${GREEN}Desktop launcher removed successfully!${NC}"
        echo -e "${YELLOW}Note: You may need to log out and back in for the change to take effect.${NC}"
    else
        echo -e "${YELLOW}Removal cancelled${NC}"
    fi
    
    read -rp "Press Enter to continue..."
}

# =============================================================================
# BUILD PROFILES FUNCTIONS
# =============================================================================

# Create a new build profile
create_build_profile() {
    echo -e "\n${BLUE}Create Build Profile${NC}"
    
    local name description configure_flags make_flags cmake_flags strip_debug use_ramdisk
    
    read -rp "Profile name: " name
    if [ -z "$name" ]; then
        error "Profile name is required"
        return 1
    fi
    
    # Check if profile already exists
    local existing
    existing=$(sqlite3 "$DB_FILE" "SELECT id FROM build_profiles WHERE name = '$(sql_escape "$name")';")
    if [ -n "$existing" ]; then
        error "Profile '$name' already exists"
        return 1
    fi
    
    read -rp "Description: " description
    read -rp "Configure flags: " configure_flags
    read -rp "Make flags: " make_flags
    read -rp "CMake flags: " cmake_flags
    
    read -rp "Strip debug symbols? (y/N): " strip_choice
    strip_debug=0
    [[ "$strip_choice" =~ ^[Yy]$ ]] && strip_debug=1
    
    read -rp "Use RAM disk? (y/N): " ramdisk_choice
    use_ramdisk=0
    [[ "$ramdisk_choice" =~ ^[Yy]$ ]] && use_ramdisk=1
    
    sqlite3 "$DB_FILE" "INSERT INTO build_profiles (name, description, configure_flags, make_flags, cmake_flags, strip_debug, use_ramdisk) 
        VALUES ('$(sql_escape "$name")', '$(sql_escape "$description")', '$(sql_escape "$configure_flags")', 
                '$(sql_escape "$make_flags")', '$(sql_escape "$cmake_flags")', $strip_debug, $use_ramdisk);"
    
    success "Build profile '$name' created" wait
}

# List build profiles
list_build_profiles() {
    echo -e "\n${BLUE}Build Profiles${NC}"
    echo "============================================"
    
    local profiles
    profiles=$(sqlite3 "$DB_FILE" "SELECT id, name, description FROM build_profiles ORDER BY name;")
    
    if [ -z "$profiles" ]; then
        echo -e "${YELLOW}No build profiles defined${NC}"
        echo -e "Use 'Create profile' to add one."
        return 1
    fi
    
    while IFS='|' read -r id name desc; do
        echo -e "${GREEN}[$id]${NC} $name"
        [ -n "$desc" ] && echo -e "    ${GRAY}$desc${NC}"
    done <<< "$profiles"
    
    echo "============================================"
}

# Apply profile to repository
apply_profile_to_repo() {
    local repo_id="$1"
    
    list_build_profiles || return 1
    
    read -rp "Enter profile ID to apply: " profile_id
    
    if ! is_valid_id "$profile_id"; then
        error "Invalid profile ID"
        return 1
    fi
    
    local profile
    profile=$(sqlite3 "$DB_FILE" "SELECT configure_flags, make_flags, cmake_flags, strip_debug, use_ramdisk FROM build_profiles WHERE id = $profile_id;")
    
    if [ -z "$profile" ]; then
        error "Profile not found"
        return 1
    fi
    
    IFS='|' read -r configure_flags make_flags cmake_flags strip_debug use_ramdisk <<< "$profile"
    
    sqlite3 "$DB_FILE" "UPDATE build_configs SET 
        configure_flags = '$(sql_escape "$configure_flags")',
        make_flags = '$(sql_escape "$make_flags")',
        cmake_flags = '$(sql_escape "$cmake_flags")',
        strip_debug = $strip_debug,
        use_ramdisk = $use_ramdisk
        WHERE repo_id = $repo_id;"
    
    success "Profile applied to repository" wait
}

# Build profiles menu
build_profiles_menu() {
    while true; do
        show_standard_layout "Build Profiles" false
        echo "1) List profiles"
        echo "2) Create profile"
        echo "3) Delete profile"
        echo "4) Apply profile to repository"
        echo "5) Save repository config as profile"
        
        echo ""
        local esc_status=0
        read_with_esc "Select option: " choice "HG" || esc_status=$?
        
        # Handle hotkeys
        case $esc_status in
            27) return 0 ;;  # Esc
            72) show_help_page; continue ;;  # H - Help
            71) goto_help_section; continue ;;  # G - Goto help section
        esac
        
        case $choice in
            1) list_build_profiles || true; read -rp "Press Enter to continue..." ;;
            2) create_build_profile ;;
            3) 
                list_build_profiles || true
                read -rp "Enter profile ID to delete: " pid
                if is_valid_id "$pid"; then
                    auto_backup "profile_delete"
                    sqlite3 "$DB_FILE" "DELETE FROM build_profiles WHERE id = $pid;"
                    success "Profile deleted"
                fi
                ;;
            4)
                read -rp "Enter repository ID: " rid
                apply_profile_to_repo "$rid"
                ;;
            5)
                read -rp "Enter repository ID: " rid
                read -rp "Enter profile name: " pname
                if [ -n "$pname" ] && is_valid_id "$rid"; then
                    local config
                    config=$(sqlite3 "$DB_FILE" "SELECT configure_flags, make_flags, cmake_flags, strip_debug, use_ramdisk FROM build_configs WHERE repo_id = $rid;")
                    if [ -n "$config" ]; then
                        IFS='|' read -r cf mf cmf sd ur <<< "$config"
                        sqlite3 "$DB_FILE" "INSERT INTO build_profiles (name, configure_flags, make_flags, cmake_flags, strip_debug, use_ramdisk) 
                            VALUES ('$(sql_escape "$pname")', '$(sql_escape "$cf")', '$(sql_escape "$mf")', '$(sql_escape "$cmf")', $sd, $ur);"
                        success "Profile '$pname' created from repository config" wait
                    fi
                fi
                ;;
            *) echo -e "${RED}Invalid option${NC}"; sleep 1 ;;
        esac
    done
}

# =============================================================================
# BUILD QUEUE FUNCTIONS
# =============================================================================

# Add repository to build queue
add_to_queue() {
    local repo_id="$1"
    local profile_id="${2:-}"
    local priority="${3:-0}"
    
    if ! is_valid_id "$repo_id"; then
        error "Invalid repository ID"
        return 1
    fi
    
    # Check if already in queue
    local existing
    existing=$(sqlite3 "$DB_FILE" "SELECT id FROM build_queue WHERE repo_id = $repo_id AND status = 'pending';")
    if [ -n "$existing" ]; then
        echo -e "${YELLOW}Repository already in queue${NC}"
        return 1
    fi
    
    local profile_clause="NULL"
    [ -n "$profile_id" ] && profile_clause="$profile_id"
    
    sqlite3 "$DB_FILE" "INSERT INTO build_queue (repo_id, profile_id, priority) VALUES ($repo_id, $profile_clause, $priority);"
    success "Added to build queue"
}

# Show build queue
show_build_queue() {
    echo -e "\n${BLUE}Build Queue${NC}"
    echo "============================================"
    
    local queue
    queue=$(sqlite3 "$DB_FILE" "SELECT q.id, r.name, q.status, q.priority, q.added_at, p.name 
        FROM build_queue q 
        JOIN repositories r ON q.repo_id = r.id 
        LEFT JOIN build_profiles p ON q.profile_id = p.id 
        ORDER BY q.priority DESC, q.added_at ASC;")
    
    if [ -z "$queue" ]; then
        echo -e "${YELLOW}Build queue is empty${NC}"
        return 1
    fi
    
    printf "%-4s %-20s %-10s %-8s %-12s %s\n" "ID" "Repository" "Status" "Priority" "Added" "Profile"
    echo "--------------------------------------------------------------------"
    
    while IFS='|' read -r id name status priority added profile; do
        local status_color="$YELLOW"
        [ "$status" = "completed" ] && status_color="$GREEN"
        [ "$status" = "failed" ] && status_color="$RED"
        [ "$status" = "building" ] && status_color="$CYAN"
        
        printf "%-4s %-20s ${status_color}%-10s${NC} %-8s %-12s %s\n" \
            "$id" "${name:0:20}" "$status" "$priority" "${added:0:10}" "${profile:-default}"
    done <<< "$queue"
    
    echo "============================================"
}

# Process build queue
process_build_queue() {
    echo -e "\n${BLUE}Processing Build Queue${NC}"
    
    local pending
    pending=$(sqlite3 "$DB_FILE" "SELECT q.id, q.repo_id, q.profile_id FROM build_queue 
        WHERE q.status = 'pending' ORDER BY q.priority DESC, q.added_at ASC;")
    
    if [ -z "$pending" ]; then
        echo -e "${YELLOW}No pending builds in queue${NC}"
        return 0
    fi
    
    local total
    total=$(echo "$pending" | wc -l)
    local current=0
    
    while IFS='|' read -r queue_id repo_id profile_id; do
        ((current++))
        
        local repo_name
        repo_name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $repo_id;")
        
        echo -e "\n${CYAN}[$current/$total] Building: $repo_name${NC}"
        
        # Update status to building
        sqlite3 "$DB_FILE" "UPDATE build_queue SET status = 'building', started_at = datetime('now') WHERE id = $queue_id;"
        
        # Apply profile if specified
        if [ -n "$profile_id" ] && [ "$profile_id" != "NULL" ]; then
            apply_profile_to_repo "$repo_id"
        fi
        
        # Build
        if download_build "$repo_id"; then
            sqlite3 "$DB_FILE" "UPDATE build_queue SET status = 'completed' WHERE id = $queue_id;"
            send_notification "Build Complete" "$repo_name built successfully"
        else
            sqlite3 "$DB_FILE" "UPDATE build_queue SET status = 'failed' WHERE id = $queue_id;"
            send_notification "Build Failed" "$repo_name build failed"
        fi
    done <<< "$pending"
    
    success "Queue processing complete" wait
}

# Clear completed/failed from queue
clear_queue() {
    local status="${1:-all}"
    
    case "$status" in
        completed) sqlite3 "$DB_FILE" "DELETE FROM build_queue WHERE status = 'completed';" ;;
        failed) sqlite3 "$DB_FILE" "DELETE FROM build_queue WHERE status = 'failed';" ;;
        pending) sqlite3 "$DB_FILE" "DELETE FROM build_queue WHERE status = 'pending';" ;;
        all) sqlite3 "$DB_FILE" "DELETE FROM build_queue;" ;;
    esac
    
    success "Queue cleared"
}

# Build queue menu
build_queue_menu() {
    while true; do
        show_standard_layout "Build Queue" false
        show_build_queue
        echo ""
        echo "1) Add repository to queue"
        echo "2) Process queue"
        echo "3) Clear completed"
        echo "4) Clear failed"
        echo "5) Clear all"
        
        echo ""
        local esc_status=0
        read_with_esc "Select option: " choice "HG" || esc_status=$?
        
        # Handle hotkeys
        case $esc_status in
            27) return 0 ;;  # Esc
            72) show_help_page; continue ;;  # H - Help
            71) goto_help_section; continue ;;  # G - Goto help section
        esac
        
        case $choice in
            1) 
                read -rp "Enter repository ID: " rid
                add_to_queue "$rid"
                ;;
            2) process_build_queue ;;
            3) clear_queue "completed" ;;
            4) clear_queue "failed" ;;
            5) clear_queue "all" ;;
            *) echo -e "${RED}Invalid option${NC}"; sleep 1 ;;
        esac
    done
}

# =============================================================================
# BUILD HISTORY FUNCTIONS
# =============================================================================

# Record build in history
record_build_history() {
    local repo_id="$1"
    local success="$2"
    local log_file="$3"
    local start_time="$4"
    local profile="${5:-}"
    
    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    # Get download metrics from exported variables
    local download_seconds="${_BUILD_DOWNLOAD_SECONDS:-0}"
    local download_size="${_BUILD_DOWNLOAD_SIZE:-0}"
    local compile_seconds=$((duration - download_seconds))
    [ "$compile_seconds" -lt 0 ] && compile_seconds=0
    
    sqlite3 "$DB_FILE" "INSERT INTO build_history (repo_id, finished_at, success, duration_seconds, download_seconds, compile_seconds, download_size_bytes, log_file, build_profile) 
        VALUES ($repo_id, datetime('now'), $success, $duration, $download_seconds, $compile_seconds, $download_size, '$(sql_escape "$log_file")', '$(sql_escape "$profile")');"
    
    # Clear the exported variables
    unset _BUILD_DOWNLOAD_SECONDS _BUILD_DOWNLOAD_SIZE
}

# Show build history
show_build_history() {
    local repo_id="${1:-}"
    local limit="${2:-20}"
    
    echo -e "\n${BLUE}Build History${NC}"
    echo "============================================"
    
    local where_clause=""
    [ -n "$repo_id" ] && where_clause="WHERE h.repo_id = $repo_id"
    
    local history
    history=$(sqlite3 "$DB_FILE" "SELECT h.id, r.name, h.started_at, h.success, h.duration_seconds 
        FROM build_history h 
        JOIN repositories r ON h.repo_id = r.id 
        $where_clause
        ORDER BY h.started_at DESC LIMIT $limit;")
    
    if [ -z "$history" ]; then
        echo -e "${YELLOW}No build history found${NC}"
        echo "============================================"
        return 0
    fi
    
    printf "%-4s %-20s %-20s %-8s %s\n" "ID" "Repository" "Date" "Status" "Duration"
    echo "--------------------------------------------------------------------"
    
    while IFS='|' read -r id name started success duration; do
        local status_text status_color
        if [ "$success" = "0" ]; then
            status_text="Success"
            status_color="$GREEN"
        else
            status_text="Failed"
            status_color="$RED"
        fi
        
        local duration_text
        if [ "$duration" -ge 3600 ]; then
            duration_text="$((duration/3600))h $((duration%3600/60))m"
        elif [ "$duration" -ge 60 ]; then
            duration_text="$((duration/60))m $((duration%60))s"
        else
            duration_text="${duration}s"
        fi
        
        printf "%-4s %-20s %-20s ${status_color}%-8s${NC} %s\n" \
            "$id" "${name:0:20}" "${started:0:19}" "$status_text" "$duration_text"
    done <<< "$history"
    
    echo "============================================"
}

# View build log from history
view_build_log() {
    local history_id="$1"
    
    local log_file
    log_file=$(sqlite3 "$DB_FILE" "SELECT log_file FROM build_history WHERE id = $history_id;")
    
    if [ -z "$log_file" ] || [ ! -f "$log_file" ]; then
        error "Build log not found"
        return 1
    fi
    
    less "$log_file"
}

# Build history menu
build_history_menu() {
    while true; do
        show_standard_layout "Build History"
        echo "1) Show all history"
        echo "2) Show history for repository"
        echo "3) View build log"
        echo "4) Clear old history"
        
        echo ""
        local esc_status=0
        read_with_esc "Select option: " choice "HG" || esc_status=$?
        
        # Handle hotkeys
        case $esc_status in
            27) return 0 ;;  # Esc
            72) show_help_page; continue ;;  # H - Help
            71) goto_help_section; continue ;;  # G - Goto help section
        esac
        
        case $choice in
            1) 
                show_build_history
                read -rp "Press Enter to continue..."
                ;;
            2)
                read -rp "Enter repository ID: " rid
                show_build_history "$rid"
                read -rp "Press Enter to continue..."
                ;;
            3)
                show_build_history
                read -rp "Enter history ID to view log: " hid
                view_build_log "$hid"
                ;;
            4)
                read -rp "Delete history older than how many days? " days
                if [[ "$days" =~ ^[0-9]+$ ]]; then
                    sqlite3 "$DB_FILE" "DELETE FROM build_history WHERE started_at < datetime('now', '-$days days');"
                    success "Old history cleared"
                fi
                ;;
            *) echo -e "${RED}Invalid option${NC}"; sleep 1 ;;
        esac
    done
}

# =============================================================================
# DEPENDENCY GRAPH FUNCTIONS
# =============================================================================

# Add dependency between repositories
add_repo_dependency() {
    local repo_id="$1"
    local depends_on="$2"
    
    if ! is_valid_id "$repo_id" || ! is_valid_id "$depends_on"; then
        error "Invalid repository ID"
        return 1
    fi
    
    if [ "$repo_id" = "$depends_on" ]; then
        error "Repository cannot depend on itself"
        return 1
    fi
    
    # Check for circular dependency
    local circular
    circular=$(sqlite3 "$DB_FILE" "WITH RECURSIVE deps(id) AS (
        SELECT depends_on_repo_id FROM repo_dependencies WHERE repo_id = $depends_on
        UNION
        SELECT d.depends_on_repo_id FROM repo_dependencies d JOIN deps ON d.repo_id = deps.id
    ) SELECT id FROM deps WHERE id = $repo_id;")
    
    if [ -n "$circular" ]; then
        error "This would create a circular dependency"
        return 1
    fi
    
    sqlite3 "$DB_FILE" "INSERT OR IGNORE INTO repo_dependencies (repo_id, depends_on_repo_id) VALUES ($repo_id, $depends_on);"
    success "Dependency added"
}

# Show dependencies for a repository
show_repo_dependencies() {
    local repo_id="$1"
    
    local repo_name
    repo_name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $repo_id;")
    
    echo -e "\n${BLUE}Dependencies for: $repo_name${NC}"
    echo "============================================"
    
    # Direct dependencies
    echo -e "${CYAN}Depends on:${NC}"
    local deps
    deps=$(sqlite3 "$DB_FILE" "SELECT r.id, r.name FROM repositories r 
        JOIN repo_dependencies d ON r.id = d.depends_on_repo_id 
        WHERE d.repo_id = $repo_id;")
    
    if [ -z "$deps" ]; then
        echo "  (none)"
    else
        while IFS='|' read -r id name; do
            echo "  [$id] $name"
        done <<< "$deps"
    fi
    
    # Reverse dependencies
    echo -e "\n${CYAN}Required by:${NC}"
    local rdeps
    rdeps=$(sqlite3 "$DB_FILE" "SELECT r.id, r.name FROM repositories r 
        JOIN repo_dependencies d ON r.id = d.repo_id 
        WHERE d.depends_on_repo_id = $repo_id;")
    
    if [ -z "$rdeps" ]; then
        echo "  (none)"
    else
        while IFS='|' read -r id name; do
            echo "  [$id] $name"
        done <<< "$rdeps"
    fi
    
    echo "============================================"
}

# Build with dependencies
build_with_dependencies() {
    local repo_id="$1"
    
    # Get all dependencies in order (topological sort)
    local build_order
    build_order=$(sqlite3 "$DB_FILE" "WITH RECURSIVE deps(id, level) AS (
        SELECT depends_on_repo_id, 1 FROM repo_dependencies WHERE repo_id = $repo_id
        UNION
        SELECT d.depends_on_repo_id, deps.level + 1 
        FROM repo_dependencies d JOIN deps ON d.repo_id = deps.id
    ) SELECT DISTINCT id FROM deps ORDER BY level DESC;")
    
    if [ -n "$build_order" ]; then
        echo -e "${BLUE}Building dependencies first...${NC}"
        while read -r dep_id; do
            local dep_name
            dep_name=$(sqlite3 "$DB_FILE" "SELECT name FROM repositories WHERE id = $dep_id;")
            echo -e "${CYAN}Building dependency: $dep_name${NC}"
            download_build "$dep_id" || {
                error "Failed to build dependency: $dep_name"
                return 1
            }
        done <<< "$build_order"
    fi
    
    # Now build the main repository
    echo -e "${BLUE}Building main repository...${NC}"
    download_build "$repo_id"
}

# Dependencies menu
dependencies_menu() {
    while true; do
        show_standard_layout "Dependencies" false
        echo "1) Show dependencies for repository"
        echo "2) Add dependency"
        echo "3) Remove dependency"
        echo "4) Build with dependencies"
        
        echo ""
        local esc_status=0
        read_with_esc "Select option: " choice "HG" || esc_status=$?
        
        # Handle hotkeys
        case $esc_status in
            27) return 0 ;;  # Esc
            72) show_help_page; continue ;;  # H - Help
            71) goto_help_section; continue ;;  # G - Goto help section
        esac
        
        case $choice in
            1)
                read -rp "Enter repository ID: " rid
                show_repo_dependencies "$rid"
                read -rp "Press Enter to continue..."
                ;;
            2)
                read -rp "Repository ID: " rid
                read -rp "Depends on repository ID: " did
                add_repo_dependency "$rid" "$did"
                ;;
            3)
                read -rp "Repository ID: " rid
                read -rp "Remove dependency on ID: " did
                sqlite3 "$DB_FILE" "DELETE FROM repo_dependencies WHERE repo_id = $rid AND depends_on_repo_id = $did;"
                success "Dependency removed"
                ;;
            4)
                read -rp "Enter repository ID: " rid
                build_with_dependencies "$rid"
                ;;
            *) echo -e "${RED}Invalid option${NC}"; sleep 1 ;;
        esac
    done
}

# =============================================================================
# SEARCH AND FILTER FUNCTIONS
# =============================================================================

# Search repositories
search_repos() {
    local query="$1"
    local escaped_query
    escaped_query=$(sql_escape "$query")
    
    echo -e "\n${BLUE}Search Results for: $query${NC}"
    echo "============================================"
    
    local results
    results=$(sqlite3 "$DB_FILE" "SELECT id, name, url, build_success FROM repositories 
        WHERE deleted = 0 AND (name LIKE '%$escaped_query%' OR url LIKE '%$escaped_query%')
        ORDER BY name;")
    
    if [ -z "$results" ]; then
        echo -e "${YELLOW}No repositories found matching '$query'${NC}"
        return 1
    fi
    
    while IFS='|' read -r id name url success; do
        local status_icon="○"
        [ "$success" = "0" ] && status_icon="${GREEN}●${NC}"
        [ "$success" = "1" ] && status_icon="${RED}●${NC}"
        
        echo -e "$status_icon [$id] $name"
        echo -e "   ${GRAY}$url${NC}"
    done <<< "$results"
    
    echo "============================================"
}

# Filter repositories by status
filter_repos_by_status() {
    local status="$1"
    
    local where_clause
    case "$status" in
        success) where_clause="build_success = 0" ;;
        failed) where_clause="build_success = 1" ;;
        unbuilt) where_clause="build_success IS NULL" ;;
        *) where_clause="1=1" ;;
    esac
    
    echo -e "\n${BLUE}Repositories: $status${NC}"
    echo "============================================"
    
    local results
    results=$(sqlite3 "$DB_FILE" "SELECT id, name FROM repositories WHERE deleted = 0 AND $where_clause ORDER BY name;")
    
    if [ -z "$results" ]; then
        echo -e "${YELLOW}No repositories found${NC}"
        return 1
    fi
    
    while IFS='|' read -r id name; do
        echo "[$id] $name"
    done <<< "$results"
    
    echo "============================================"
}

# =============================================================================
# NOTIFICATION FUNCTIONS
# =============================================================================

# Send desktop notification
send_notification() {
    local title="$1"
    local message="$2"
    
    # Check if notifications are enabled
    if [ "${NOTIFICATIONS_ENABLED:-true}" != "true" ]; then
        return 0
    fi
    
    # Try different notification methods
    if command -v notify-send >/dev/null 2>&1; then
        notify-send "GitBuilder: $title" "$message" 2>/dev/null || true
    elif command -v osascript >/dev/null 2>&1; then
        osascript -e "display notification \"$message\" with title \"GitBuilder: $title\"" 2>/dev/null || true
    fi
}

# =============================================================================
# AUTO-UPDATE CHECK
# =============================================================================

# Check for GitBuilder updates
check_for_updates() {
    echo -e "${BLUE}Checking for updates...${NC}"
    
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    local base_url="https://raw.githubusercontent.com/vr51/GitBuilder/main"
    
    # Get remote version
    local remote_version
    remote_version=$(curl -s "$base_url/gitbuilder" 2>/dev/null | grep "^VERSION=" | head -1 | cut -d'"' -f2)
    
    if [ -z "$remote_version" ]; then
        echo -e "${YELLOW}Could not check for updates${NC}"
        return 1
    fi
    
    if [ "$remote_version" = "$VERSION" ]; then
        echo -e "${GREEN}You are running the latest version ($VERSION)${NC}"
        return 0
    fi
    
    echo -e "${GREEN}New version available: $remote_version (current: $VERSION)${NC}"
    echo ""
    read -rp "Would you like to download and install the update? (y/N): " install_update
    
    if [[ ! "$install_update" =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}Update cancelled${NC}"
        return 0
    fi
    
    echo -e "${BLUE}Downloading update...${NC}"
    
    # Create temp directory for download
    local temp_dir
    temp_dir=$(mktemp -d)
    trap "rm -rf '$temp_dir'" EXIT
    
    # Download files
    local download_failed=false
    
    # Download main script (required)
    if curl -s "$base_url/gitbuilder" -o "$temp_dir/gitbuilder"; then
        echo -e "  ${GREEN}✓${NC} gitbuilder"
    else
        echo -e "  ${RED}✗${NC} gitbuilder (download failed)"
        download_failed=true
    fi
    
    # Download HELP (required)
    if curl -s "$base_url/HELP" -o "$temp_dir/HELP"; then
        echo -e "  ${GREEN}✓${NC} HELP"
    else
        echo -e "  ${RED}✗${NC} HELP (download failed)"
        download_failed=true
    fi
    
    # Download README.md (optional, don't fail if missing)
    if curl -s "$base_url/README.md" -o "$temp_dir/README.md" 2>/dev/null; then
        echo -e "  ${GREEN}✓${NC} README.md"
    else
        echo -e "  ${YELLOW}○${NC} README.md (not available)"
    fi
    
    # Download gitbuildfiles directory (optional, don't overwrite existing)
    local gitbuildfiles_url="$base_url/gitbuildfiles"
    # Try to get list of gitbuildfiles from GitHub API
    local gitbuildfiles_list
    gitbuildfiles_list=$(curl -s "https://api.github.com/repos/vr51/GitBuilder/contents/gitbuildfiles" 2>/dev/null | grep '"name"' | cut -d'"' -f4)
    
    if [ -n "$gitbuildfiles_list" ]; then
        mkdir -p "$temp_dir/gitbuildfiles"
        mkdir -p "$script_dir/gitbuildfiles"
        echo -e "  ${BLUE}Checking gitbuildfiles...${NC}"
        while IFS= read -r file; do
            [ -z "$file" ] && continue
            # Only download if file doesn't exist locally
            if [ ! -f "$script_dir/gitbuildfiles/$file" ]; then
                if curl -s "$gitbuildfiles_url/$file" -o "$temp_dir/gitbuildfiles/$file" 2>/dev/null; then
                    echo -e "    ${GREEN}✓${NC} $file (new)"
                fi
            else
                echo -e "    ${YELLOW}○${NC} $file (keeping existing)"
            fi
        done <<< "$gitbuildfiles_list"
    fi
    
    if [ "$download_failed" = true ]; then
        echo -e "${RED}Download failed. Update cancelled.${NC}"
        return 1
    fi
    
    # Verify downloaded script has correct version
    local downloaded_version
    downloaded_version=$(grep "^VERSION=" "$temp_dir/gitbuilder" | head -1 | cut -d'"' -f2)
    if [ "$downloaded_version" != "$remote_version" ]; then
        echo -e "${RED}Downloaded file version mismatch. Update cancelled.${NC}"
        return 1
    fi
    
    echo ""
    echo -e "${BLUE}Installing update...${NC}"
    
    # Backup current gitbuilder script (keep only one backup)
    if [ -f "$script_dir/gitbuilder" ]; then
        cp "$script_dir/gitbuilder" "$script_dir/gitbuilder.backup"
        echo -e "  ${GREEN}✓${NC} Backed up current version to gitbuilder.backup"
    fi
    
    # Install new files
    cp "$temp_dir/gitbuilder" "$script_dir/gitbuilder"
    chmod +x "$script_dir/gitbuilder"
    echo -e "  ${GREEN}✓${NC} Installed gitbuilder"
    
    cp "$temp_dir/HELP" "$script_dir/HELP"
    echo -e "  ${GREEN}✓${NC} Installed HELP"
    
    if [ -f "$temp_dir/README.md" ]; then
        cp "$temp_dir/README.md" "$script_dir/README.md"
        echo -e "  ${GREEN}✓${NC} Installed README.md"
    fi
    
    # Install new gitbuildfiles (only new ones)
    if [ -d "$temp_dir/gitbuildfiles" ]; then
        for file in "$temp_dir/gitbuildfiles"/*; do
            [ -f "$file" ] || continue
            local filename
            filename=$(basename "$file")
            cp "$file" "$script_dir/gitbuildfiles/$filename"
            echo -e "  ${GREEN}✓${NC} Installed gitbuildfiles/$filename"
        done
    fi
    
    echo ""
    echo -e "${GREEN}Update complete! GitBuilder updated to version $remote_version${NC}"
    echo -e "${YELLOW}Please restart GitBuilder to use the new version.${NC}"
    
    read -rp "Restart now? (Y/n): " restart_now
    if [[ ! "$restart_now" =~ ^[Nn]$ ]]; then
        exec "$script_dir/gitbuilder"
    fi
    
    return 0
}

# =============================================================================
# THEME MENU
# =============================================================================

theme_menu() {
    while true; do
        show_standard_layout "Theme Settings" false
        echo -e "Current theme: ${GREEN}$THEME${NC}"
        echo ""
        echo "1) Default"
        echo "2) Ocean"
        echo "3) Forest"
        echo "4) Mono (no colors)"
        
        echo ""
        local esc_status=0
        read_with_esc "Select theme: " choice "HG" || esc_status=$?
        
        # Handle hotkeys
        case $esc_status in
            27) return 0 ;;  # Esc
            72) show_help_page; continue ;;  # H - Help
            71) goto_help_section; continue ;;  # G - Goto help section
        esac
        
        case $choice in
            1) THEME="default" ;;
            2) THEME="ocean" ;;
            3) THEME="forest" ;;
            4) THEME="mono" ;;
            *) echo -e "${RED}Invalid option${NC}"; sleep 1; continue ;;
        esac
        
        apply_theme "$THEME"
        save_config
        success "Theme changed to: $THEME"
        sleep 1
    done
}

# =============================================================================
# SETTINGS MENU
# =============================================================================

settings_menu() {
    while true; do
        show_standard_layout "Settings" false
        echo -e "${GRAY}Help: G + 6${NC}"
        echo "1) Theme: $THEME"
        echo "2) Notifications: ${NOTIFICATIONS_ENABLED:-true}"
        echo "3) Auto-update check: every ${AUTO_UPDATE_CHECK_DAYS:-7} days"
        echo "4) Check for updates now"
        echo "5) Backup database"
        echo "6) Restore database"
        
        echo ""
        local esc_status=0
        read_with_esc "Select option: " choice "HG" || esc_status=$?
        
        # Handle hotkeys
        case $esc_status in
            27) return 0 ;;  # Esc
            72) show_help_page; continue ;;  # H - Help
            71) goto_help_section; continue ;;  # G - Goto help section
        esac
        
        case $choice in
            1) theme_menu ;;
            2)
                if [ "${NOTIFICATIONS_ENABLED:-true}" = "true" ]; then
                    NOTIFICATIONS_ENABLED="false"
                else
                    NOTIFICATIONS_ENABLED="true"
                fi
                save_config
                success "Notifications: $NOTIFICATIONS_ENABLED"
                sleep 1
                ;;
            3)
                read -rp "Check for updates every how many days? (0 to disable): " days
                if [[ "$days" =~ ^[0-9]+$ ]]; then
                    AUTO_UPDATE_CHECK_DAYS="$days"
                    save_config
                    success "Auto-update check interval set to $days days"
                fi
                sleep 1
                ;;
            4) check_for_updates; read -rp "Press Enter to continue..." ;;
            5) backup_database ;;
            6) restore_database ;;
            *) echo -e "${RED}Invalid option${NC}"; sleep 1 ;;
        esac
    done
}

# =============================================================================
# COMMAND LINE ARGUMENT HANDLING
# =============================================================================

# Parse remaining command line arguments (after help/version)
parse_args() {
    while [ $# -gt 0 ]; do
        case "$1" in
            -l|--list)
                check_requirements
                init_db
                show_repos
                exit 0
                ;;
            -b|--build)
                shift
                if [ -z "${1:-}" ]; then
                    echo "Error: --build requires a repository ID"
                    exit 1
                fi
                check_requirements
                init_db
                download_build "$1"
                exit $?
                ;;
            -u|--update)
                check_requirements
                init_db
                update_all_repos
                exit 0
                ;;
            --backup)
                shift
                check_requirements
                init_db
                backup_database "${1:-}"
                exit $?
                ;;
            --restore)
                shift
                if [ -z "${1:-}" ]; then
                    echo "Error: --restore requires a backup file"
                    exit 1
                fi
                check_requirements
                init_db
                restore_database "$1"
                exit $?
                ;;
            --check-update)
                check_for_updates
                exit $?
                ;;
            *)
                echo "Unknown option: $1"
                echo "Use --help for usage information"
                exit 1
                ;;
        esac
        shift
    done
}

# Parse command line arguments
parse_args "$@"

# Main execution
check_requirements
init_db
update_repository_info
check_gitbuilder_launcher
main_menu
